var tipuesearch = {"pages":[{"title":" Seakeeping ","text":"Seakeeping seakeeping 是一个适用于船舶耐波性相关计算的函数包。 基于编程经验，对特定领域编写更详实的表达型代码，有助于从底层提高代码的可读性、可维护性、可描述性。 于是，形成了这个包，用于表达、计算船舶耐波性问题。事实证明，本包的确提高了我的编码效率与代码复用。 除此之外，还有 fffc 通用函数库，kissfft-f 快速傅里叶变换库，以及其他一些包，可以用于船舶耐波性问题的求解。 使用 Meson 编译 本包也支持使用 meson 构建，可以使用 meson 的 subproject 功能，将 seakeeping 作为子项目引入。 > meson setup _build # 配置 meson 构建目录 > meson compile -C _build # 编译 在 meson.build 中，可以使用 subproject 函数引入 seakeeping ： seakeeping_dep = subproject ( 'seakeeping' ). get_variable ( 'seakeeping_dep' ) 理论上，Meson 支持 Windows/macOS/Linux 下的 gfortran, macOS/Linux 下的 ifort。\n若需要支持 Windows 下的 ifort, 可搭配 VS2022 进行编译。 其他包 这里列举其他适用于船舶耐波性问题的包： minpack/nlopt-f：非线性方程组求解； fftw/fftpack：快速傅里叶变换； fgsl/gsl：通用数学函数； toml-f：配置文件，终端； M_CLI2：命令行； test-drive：单元测试； root-fortran：根查找； polyroot-fortran：多项式根查找； quadrature-fortran：多维高斯-勒让德积分； VTKFortran/H5part：存储与可视化； Source Codes in Fortran90: Fortran 90 代码。 此外，还有 CAE 模型的解析和数值模型可视化，技术细节层面如函数积分、统计、排序、特殊函数等内容。 Developer Info 左志华 哈尔滨工程大学-船舶与海洋结构物设计制造，在读学生","tags":"home","loc":"index.html"},{"title":"vector – Seakeeping ","text":"type, public :: vector Vector 泛型向量 Contents Variables len Type-Bound Procedures init pop push set get clear Source Code vector Components Type Visibility Attributes Name Initial integer, public :: len = 0 有效向量长度 Type-Bound Procedures procedure, public,  :: init private pure subroutine init(self) 初始化向量 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self procedure, public,  :: pop private  subroutine pop(self, item) 向量弹出 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class(*), intent(out), optional, allocatable :: item procedure, public,  :: push private pure subroutine push(self, item) 向量压入 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class(*), intent(in) :: item procedure, public,  :: set private pure subroutine set(self, index, item) 向量设置 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index class(*), intent(in) :: item procedure, public,  :: get private  subroutine get(self, index, item) 向量获取 Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: index class(*), intent(out), allocatable :: item procedure, public,  :: clear private pure subroutine clear(self) 向量清空 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Source Code type vector private integer , public :: len = 0 !! 有效向量长度 type ( node ), allocatable :: items (:) !! 泛型数组 contains procedure :: init procedure :: push , pop procedure :: get , set procedure :: clear procedure , private :: extend end type vector","tags":"","loc":"type/vector.html"},{"title":"stack_real – Seakeeping ","text":"type, public :: stack_real 堆栈 Contents Variables len Type-Bound Procedures push pop iterator clear Source Code stack_real Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the stack_real Type-Bound Procedures procedure, public,  :: push => stack_real_push private pure subroutine stack_real_push(self, item) push an item to the stack_real Arguments Type Intent Optional Attributes Name class( stack_real ), intent(inout) :: self real(kind=rk), intent(in) :: item procedure, public,  :: pop => stack_real_pop private pure subroutine stack_real_pop(self, item) pop an item from the stack_real Arguments Type Intent Optional Attributes Name class( stack_real ), intent(inout) :: self real(kind=rk), intent(out), optional :: item procedure, public,  :: iterator private  function iterator(self) result(iter) Get an stack_real_iterator for the stack_real Arguments Type Intent Optional Attributes Name class( stack_real ), intent(in) :: self Return Value type( stack_real_iterator ) procedure, public,  :: clear => stack_real_clear private pure subroutine stack_real_clear(self) Clear the stack_real Arguments Type Intent Optional Attributes Name class( stack_real ), intent(inout) :: self Source Code type stack_real private integer , public :: len = 0 !! number of nodes in the stack_real type ( node ), pointer :: head => null () !! head of the stack_real type ( node ), pointer :: tail => null () !! tail of the stack_real contains procedure :: push => stack_real_push procedure :: pop => stack_real_pop procedure :: iterator procedure :: clear => stack_real_clear end type stack_real","tags":"","loc":"type/stack_real.html"},{"title":"stack_real_iterator – Seakeeping ","text":"type, public :: stack_real_iterator 迭代器 Contents Type-Bound Procedures next clear Source Code stack_real_iterator Type-Bound Procedures procedure, public,  :: next => stack_real_iterator_next private pure subroutine stack_real_iterator_next(self, item) Get the next item from the stack_real_iterator Arguments Type Intent Optional Attributes Name class( stack_real_iterator ), intent(inout) :: self real(kind=rk), intent(out) :: item procedure, public,  :: clear => stack_real_iterator_clear private pure subroutine stack_real_iterator_clear(self) Clear the stack_real_iterator Arguments Type Intent Optional Attributes Name class( stack_real_iterator ), intent(inout) :: self Source Code type stack_real_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => stack_real_iterator_next procedure :: clear => stack_real_iterator_clear end type stack_real_iterator","tags":"","loc":"type/stack_real_iterator.html"},{"title":"vector_real – Seakeeping ","text":"type, public :: vector_real Vector_real 实数向量 Contents Variables len Type-Bound Procedures init pop push set get clear Source Code vector_real Components Type Visibility Attributes Name Initial integer, public :: len = 0 有效向量长度 Type-Bound Procedures procedure, public,  :: init private pure subroutine init(self) 初始化向量 Arguments Type Intent Optional Attributes Name class( vector_real ), intent(inout) :: self procedure, public,  :: pop private pure subroutine pop(self, item) 向量弹出 Arguments Type Intent Optional Attributes Name class( vector_real ), intent(inout) :: self real(kind=rk), intent(out), optional :: item procedure, public,  :: push private pure subroutine push(self, item) 向量压入 Arguments Type Intent Optional Attributes Name class( vector_real ), intent(inout) :: self real(kind=rk), intent(in) :: item procedure, public,  :: set private pure subroutine set(self, index, item) 向量设置 Arguments Type Intent Optional Attributes Name class( vector_real ), intent(inout) :: self integer, intent(in) :: index real(kind=rk), intent(in) :: item procedure, public,  :: get private pure subroutine get(self, index, item) 向量获取 Arguments Type Intent Optional Attributes Name class( vector_real ), intent(in) :: self integer, intent(in) :: index real(kind=rk), intent(out) :: item procedure, public,  :: clear private pure subroutine clear(self) 向量清空 Arguments Type Intent Optional Attributes Name class( vector_real ), intent(inout) :: self Source Code type vector_real private integer , public :: len = 0 !! 有效向量长度 real ( rk ), allocatable :: items (:) !! 实数数组 contains procedure :: init procedure :: push , pop procedure :: get , set procedure :: clear procedure , private :: extend end type vector_real","tags":"","loc":"type/vector_real.html"},{"title":"queue – Seakeeping ","text":"type, public :: queue 队列 Contents Variables len Type-Bound Procedures enqueue dequeue iterator clear Source Code queue Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the queue Type-Bound Procedures procedure, public,  :: enqueue => queue_enqueue private pure subroutine queue_enqueue(self, item) Enqueue an item to the queue Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self class(*), intent(in) :: item procedure, public,  :: dequeue => queue_dequeue private  subroutine queue_dequeue(self, item) Dequeue an item from the queue Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self class(*), intent(out), optional, allocatable :: item procedure, public,  :: iterator private  function iterator(self) result(iter) Get an queue_iterator for the queue Arguments Type Intent Optional Attributes Name class( queue ), intent(in) :: self Return Value type( queue_iterator ) procedure, public,  :: clear => queue_clear private pure subroutine queue_clear(self) Clear the queue Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self Source Code type queue private integer , public :: len = 0 !! number of nodes in the queue type ( node ), pointer :: head => null () !! head of the queue type ( node ), pointer :: tail => null () !! tail of the queue contains procedure :: enqueue => queue_enqueue procedure :: dequeue => queue_dequeue procedure :: iterator procedure :: clear => queue_clear end type queue","tags":"","loc":"type/queue.html"},{"title":"queue_iterator – Seakeeping ","text":"type, public :: queue_iterator 迭代器 Contents Type-Bound Procedures next clear Source Code queue_iterator Type-Bound Procedures procedure, public,  :: next => queue_iterator_next private  subroutine queue_iterator_next(self, item) Get the next item from the queue_iterator Arguments Type Intent Optional Attributes Name class( queue_iterator ), intent(inout) :: self class(*), intent(out), allocatable :: item procedure, public,  :: clear => queue_iterator_clear private pure subroutine queue_iterator_clear(self) Clear the queue_iterator Arguments Type Intent Optional Attributes Name class( queue_iterator ), intent(inout) :: self Source Code type queue_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => queue_iterator_next procedure :: clear => queue_iterator_clear end type queue_iterator","tags":"","loc":"type/queue_iterator.html"},{"title":"stack – Seakeeping ","text":"type, public :: stack 堆栈 Contents Variables len Type-Bound Procedures push pop iterator clear Source Code stack Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the stack Type-Bound Procedures procedure, public,  :: push => stack_push private pure subroutine stack_push(self, item) push an item to the stack Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: self class(*), intent(in) :: item procedure, public,  :: pop => stack_pop private  subroutine stack_pop(self, item) pop an item from the stack Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: self class(*), intent(out), optional, allocatable :: item procedure, public,  :: iterator private  function iterator(self) result(iter) Get an stack_iterator for the stack Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: self Return Value type( stack_iterator ) procedure, public,  :: clear => stack_clear private pure subroutine stack_clear(self) Clear the stack Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: self Source Code type stack private integer , public :: len = 0 !! number of nodes in the stack type ( node ), pointer :: head => null () !! head of the stack type ( node ), pointer :: tail => null () !! tail of the stack contains procedure :: push => stack_push procedure :: pop => stack_pop procedure :: iterator procedure :: clear => stack_clear end type stack","tags":"","loc":"type/stack.html"},{"title":"stack_iterator – Seakeeping ","text":"type, public :: stack_iterator 迭代器 Contents Type-Bound Procedures next clear Source Code stack_iterator Type-Bound Procedures procedure, public,  :: next => stack_iterator_next private  subroutine stack_iterator_next(self, item) Get the next item from the stack_iterator Arguments Type Intent Optional Attributes Name class( stack_iterator ), intent(inout) :: self class(*), intent(out), allocatable :: item procedure, public,  :: clear => stack_iterator_clear private pure subroutine stack_iterator_clear(self) Clear the stack_iterator Arguments Type Intent Optional Attributes Name class( stack_iterator ), intent(inout) :: self Source Code type stack_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => stack_iterator_next procedure :: clear => stack_iterator_clear end type stack_iterator","tags":"","loc":"type/stack_iterator.html"},{"title":"queue_real – Seakeeping ","text":"type, public :: queue_real 队列 Contents Variables len Type-Bound Procedures enqueue dequeue iterator clear Source Code queue_real Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the queue Type-Bound Procedures procedure, public,  :: enqueue => queue_enqueue private pure subroutine queue_enqueue(self, item) Enqueue an item to the queue Arguments Type Intent Optional Attributes Name class( queue_real ), intent(inout) :: self real(kind=rk), intent(in) :: item procedure, public,  :: dequeue => queue_dequeue private pure subroutine queue_dequeue(self, item) Dequeue an item from the queue Arguments Type Intent Optional Attributes Name class( queue_real ), intent(inout) :: self real(kind=rk), intent(out), optional :: item procedure, public,  :: iterator private  function iterator(self) result(iter) Get an queue_real_iterator for the queue Arguments Type Intent Optional Attributes Name class( queue_real ), intent(in) :: self Return Value type( queue_real_iterator ) procedure, public,  :: clear => queue_clear private pure subroutine queue_clear(self) Clear the queue Arguments Type Intent Optional Attributes Name class( queue_real ), intent(inout) :: self Source Code type queue_real private integer , public :: len = 0 !! number of nodes in the queue type ( node ), pointer :: head => null () !! head of the queue type ( node ), pointer :: tail => null () !! tail of the queue contains procedure :: enqueue => queue_enqueue procedure :: dequeue => queue_dequeue procedure :: iterator procedure :: clear => queue_clear end type queue_real","tags":"","loc":"type/queue_real.html"},{"title":"queue_real_iterator – Seakeeping ","text":"type, public :: queue_real_iterator 迭代器 Contents Type-Bound Procedures next clear Source Code queue_real_iterator Type-Bound Procedures procedure, public,  :: next => queue_iterator_next private pure subroutine queue_iterator_next(self, item) Get the next item from the queue_real_iterator Arguments Type Intent Optional Attributes Name class( queue_real_iterator ), intent(inout) :: self real(kind=rk), intent(out) :: item procedure, public,  :: clear => queue_iterator_clear private pure subroutine queue_iterator_clear(self) Clear the queue_real_iterator Arguments Type Intent Optional Attributes Name class( queue_real_iterator ), intent(inout) :: self Source Code type queue_real_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => queue_iterator_next procedure :: clear => queue_iterator_clear end type queue_real_iterator","tags":"","loc":"type/queue_real_iterator.html"},{"title":"stack_int – Seakeeping ","text":"type, public :: stack_int 堆栈 Contents Variables len Type-Bound Procedures push pop iterator clear Source Code stack_int Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the stack_int Type-Bound Procedures procedure, public,  :: push => stack_int_push private pure subroutine stack_int_push(self, item) push an item to the stack_int Arguments Type Intent Optional Attributes Name class( stack_int ), intent(inout) :: self integer, intent(in) :: item procedure, public,  :: pop => stack_int_pop private pure subroutine stack_int_pop(self, item) pop an item from the stack_int Arguments Type Intent Optional Attributes Name class( stack_int ), intent(inout) :: self integer, intent(out), optional :: item procedure, public,  :: iterator private  function iterator(self) result(iter) Get an stack_int_iterator for the stack_int Arguments Type Intent Optional Attributes Name class( stack_int ), intent(in) :: self Return Value type( stack_int_iterator ) procedure, public,  :: clear => stack_int_clear private pure subroutine stack_int_clear(self) Clear the stack_int Arguments Type Intent Optional Attributes Name class( stack_int ), intent(inout) :: self Source Code type stack_int private integer , public :: len = 0 !! number of nodes in the stack_int type ( node ), pointer :: head => null () !! head of the stack_int type ( node ), pointer :: tail => null () !! tail of the stack_int contains procedure :: push => stack_int_push procedure :: pop => stack_int_pop procedure :: iterator procedure :: clear => stack_int_clear end type stack_int","tags":"","loc":"type/stack_int.html"},{"title":"stack_int_iterator – Seakeeping ","text":"type, public :: stack_int_iterator 迭代器 Contents Type-Bound Procedures next clear Source Code stack_int_iterator Type-Bound Procedures procedure, public,  :: next => stack_int_iterator_next private pure subroutine stack_int_iterator_next(self, item) Get the next item from the stack_int_iterator Arguments Type Intent Optional Attributes Name class( stack_int_iterator ), intent(inout) :: self integer, intent(out) :: item procedure, public,  :: clear => stack_int_iterator_clear private pure subroutine stack_int_iterator_clear(self) Clear the stack_int_iterator Arguments Type Intent Optional Attributes Name class( stack_int_iterator ), intent(inout) :: self Source Code type stack_int_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => stack_int_iterator_next procedure :: clear => stack_int_iterator_clear end type stack_int_iterator","tags":"","loc":"type/stack_int_iterator.html"},{"title":"vector_int – Seakeeping ","text":"type, public :: vector_int Vector_int 整型向量 Contents Variables len Type-Bound Procedures init pop push set get clear Source Code vector_int Components Type Visibility Attributes Name Initial integer, public :: len = 0 有效向量长度 Type-Bound Procedures procedure, public,  :: init private pure subroutine init(self) 初始化向量 Arguments Type Intent Optional Attributes Name class( vector_int ), intent(inout) :: self procedure, public,  :: pop private pure subroutine pop(self, item) 向量弹出 Arguments Type Intent Optional Attributes Name class( vector_int ), intent(inout) :: self integer, intent(out), optional :: item procedure, public,  :: push private pure subroutine push(self, item) 向量压入 Arguments Type Intent Optional Attributes Name class( vector_int ), intent(inout) :: self integer, intent(in) :: item procedure, public,  :: set private pure subroutine set(self, index, item) 向量设置 Arguments Type Intent Optional Attributes Name class( vector_int ), intent(inout) :: self integer, intent(in) :: index integer, intent(in) :: item procedure, public,  :: get private pure subroutine get(self, index, item) 向量获取 Arguments Type Intent Optional Attributes Name class( vector_int ), intent(in) :: self integer, intent(in) :: index integer, intent(out) :: item procedure, public,  :: clear private pure subroutine clear(self) 向量清空 Arguments Type Intent Optional Attributes Name class( vector_int ), intent(inout) :: self Source Code type vector_int private integer , public :: len = 0 !! 有效向量长度 integer , allocatable :: items (:) !! 整型数组 contains procedure :: init procedure :: push , pop procedure :: get , set procedure :: clear procedure , private :: extend end type vector_int","tags":"","loc":"type/vector_int.html"},{"title":"queue_int – Seakeeping ","text":"type, public :: queue_int 队列 Contents Variables len Type-Bound Procedures enqueue dequeue iterator clear Source Code queue_int Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the queue Type-Bound Procedures procedure, public,  :: enqueue => queue_enqueue private pure subroutine queue_enqueue(self, item) Enqueue an item to the queue Arguments Type Intent Optional Attributes Name class( queue_int ), intent(inout) :: self integer, intent(in) :: item procedure, public,  :: dequeue => queue_dequeue private  subroutine queue_dequeue(self, item) Dequeue an item from the queue Arguments Type Intent Optional Attributes Name class( queue_int ), intent(inout) :: self integer, intent(out), optional :: item procedure, public,  :: iterator private  function iterator(self) result(iter) Get an queue_int_iterator for the queue Arguments Type Intent Optional Attributes Name class( queue_int ), intent(in) :: self Return Value type( queue_int_iterator ) procedure, public,  :: clear => queue_clear private pure subroutine queue_clear(self) Clear the queue Arguments Type Intent Optional Attributes Name class( queue_int ), intent(inout) :: self Source Code type queue_int private integer , public :: len = 0 !! number of nodes in the queue type ( node ), pointer :: head => null () !! head of the queue type ( node ), pointer :: tail => null () !! tail of the queue contains procedure :: enqueue => queue_enqueue procedure :: dequeue => queue_dequeue procedure :: iterator procedure :: clear => queue_clear end type queue_int","tags":"","loc":"type/queue_int.html"},{"title":"queue_int_iterator – Seakeeping ","text":"type, public :: queue_int_iterator 迭代器 Contents Type-Bound Procedures next clear Source Code queue_int_iterator Type-Bound Procedures procedure, public,  :: next => queue_iterator_next private  subroutine queue_iterator_next(self, item) Get the next item from the queue_int_iterator Arguments Type Intent Optional Attributes Name class( queue_int_iterator ), intent(inout) :: self integer, intent(out) :: item procedure, public,  :: clear => queue_iterator_clear private pure subroutine queue_iterator_clear(self) Clear the queue_int_iterator Arguments Type Intent Optional Attributes Name class( queue_int_iterator ), intent(inout) :: self Source Code type queue_int_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => queue_iterator_next procedure :: clear => queue_iterator_clear end type queue_int_iterator","tags":"","loc":"type/queue_int_iterator.html"},{"title":"k01 – Seakeeping","text":"public elemental function k01(w) result(k0) Wave number from wave frequency 波频率计算波数 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: w Return Value real(kind=rk) Contents Source Code k01 Source Code elemental real ( rk ) function k01 ( w ) result ( k0 ) real ( rk ), intent ( in ) :: w k0 = w * w / g end function k01","tags":"","loc":"proc/k01.html"},{"title":"k02 – Seakeeping","text":"public elemental function k02(l) result(k0) Wave number from wave length 波长计算波数 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: l Return Value real(kind=rk) Contents Source Code k02 Source Code elemental real ( rk ) function k02 ( l ) result ( k0 ) real ( rk ), intent ( in ) :: l k0 = pi2 / l end function k02","tags":"","loc":"proc/k02.html"},{"title":"we – Seakeeping","text":"public elemental function we(w, v, deg) Encountered wave frequency 遭遇波频率 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: w Wave frequency 波频率 real(kind=rk), intent(in) :: v Ship speed 船舶速度 real(kind=rk), intent(in), optional :: deg Ship heading 船舶航向 Return Value real(kind=rk) Contents Source Code we Source Code elemental real ( rk ) function we ( w , v , deg ) real ( rk ), intent ( in ) :: w !! Wave frequency <br> !! 波频率 real ( rk ), intent ( in ) :: v !! Ship speed <br> !! 船舶速度 real ( rk ), intent ( in ), optional :: deg !! Ship heading <br> !! 船舶航向 if ( present ( deg )) then we = w + k01 ( w ) * v * cos ( deg ) else we = w + k01 ( w ) * v end if end function we","tags":"","loc":"proc/we.html"},{"title":"wlr – Seakeeping","text":"public elemental function wlr(w, l) Wavelength to length ratio 波长与船长比 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: w Wave frequency 波频率 real(kind=rk), intent(in) :: l Ship length 船舶特征长度 Return Value real(kind=rk) Contents Source Code wlr Source Code elemental real ( rk ) function wlr ( w , l ) real ( rk ), intent ( in ) :: w !! Wave frequency <br> !! 波频率 real ( rk ), intent ( in ) :: l !! Ship length <br> !! 船舶特征长度 wlr = pi2 / ( k01 ( w ) * l ) end function wlr","tags":"","loc":"proc/wlr.html"},{"title":"wf – Seakeeping","text":"public elemental function wf(wlr, l) Wave frequency from wlr 由波长与船长比计算波频率 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: wlr Wavelength to length ratio 波长与船长比 real(kind=rk), intent(in) :: l Ship length 船舶特征长度 Return Value real(kind=rk) Contents Source Code wf Source Code elemental real ( rk ) function wf ( wlr , l ) real ( rk ), intent ( in ) :: wlr !! Wavelength to length ratio <br> !! 波长与船长比 real ( rk ), intent ( in ) :: l !! Ship length <br> !! 船舶特征长度 wf = sqrt ( g * k02 ( wlr * l )) end function wf","tags":"","loc":"proc/wf.html"},{"title":"wenergy – Seakeeping","text":"public elemental function wenergy(rho, a) Wave energy 波能：动能 + 势能, Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho Water density 水密度 real(kind=rk), intent(in) :: a Wave amplitude 波幅 Return Value real(kind=rk) Contents Source Code wenergy Source Code elemental real ( rk ) function wenergy ( rho , a ) real ( rk ), intent ( in ) :: rho !! Water density <br> !! 水密度 real ( rk ), intent ( in ) :: a !! Wave amplitude <br> !! 波幅 wenergy = rho * g * a * a / 2 end function wenergy","tags":"","loc":"proc/wenergy.html"},{"title":"zeta – Seakeeping","text":"public pure function zeta(k, x, y, w, t, beta, phase) 单位波幅： \\zeta = \\sin(kx\\cos\\beta + ky\\sin\\beta + \\omega t + phase)  Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: k real(kind=rk), intent(in) :: x real(kind=rk), intent(in) :: y real(kind=rk), intent(in) :: w real(kind=rk), intent(in) :: t real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: phase Return Value real(kind=rk) Contents Source Code zeta Source Code real ( rk ) pure function zeta ( k , x , y , w , t , beta , phase ) real ( rk ), intent ( in ) :: k , x , y , w , t , beta , phase zeta = sin ( k * x * cos ( beta ) + k * y * sin ( beta ) + w * t + phase ) end function zeta","tags":"","loc":"proc/zeta.html"},{"title":"vdeep – Seakeeping","text":"public pure function vdeep(lambda) 深水波波速 Note 确保水深大于半波长，造波机多次前后移动制造深水波，波长越大的后波将追赶前波，\n 最终水面波可叠加形成一条大浪 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: lambda Return Value real(kind=rk) Contents Source Code vdeep Source Code real ( rk ) pure function vdeep ( lambda ) real ( rk ), intent ( in ) :: lambda vdeep = sqrt ( g * lambda / ( pi2 )) end function vdeep","tags":"","loc":"proc/vdeep.html"},{"title":"ittc_tpwes_waveamplitude – Seakeeping","text":"public pure subroutine ittc_tpwes_waveamplitude(omega, domega, t1, hs, wave_amplitude) 12th-ITTC (1969) 双参数波能谱模型计算频段有义波幅\nITTC two-parameter wave energy spectrum Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omega 波浪角频率, rad/s real(kind=rk), intent(in) :: domega 频率间隔, rad/s real(kind=rk), intent(in) :: t1 平均周期, s, T1 = 2 pi m0/m1 real(kind=rk), intent(in) :: hs 有义波高, m real(kind=rk), intent(out) :: wave_amplitude 频段有义波幅, m Contents Source Code ittc_tpwes_waveamplitude Source Code pure subroutine ittc_tpwes_waveamplitude ( omega , domega , t1 , hs , wave_amplitude ) real ( kind = rk ), intent ( in ) :: omega !! 波浪角频率, rad/s real ( kind = rk ), intent ( in ) :: domega !! 频率间隔, rad/s real ( kind = rk ), intent ( in ) :: t1 !! 平均周期, s, T1 = 2*pi*m0/m1 real ( kind = rk ), intent ( in ) :: hs !! 有义波高, m real ( kind = rk ), intent ( out ) :: wave_amplitude !! 频段有义波幅, m real ( kind = rk ) :: s associate ( a => 173 * hs ** 2 / t1 ** 4 , b => 691 / t1 ** 4 ) s = a * exp ( - b / omega ** 4 ) / omega ** 5 wave_amplitude = sqrt ( 2 * s * domega ) ! A = sqrt(2*S_\\omega*d\\omega) end associate end subroutine ittc_tpwes_waveamplitude","tags":"","loc":"proc/ittc_tpwes_waveamplitude.html"},{"title":"ittc_spwes_waveamplitude – Seakeeping","text":"public pure subroutine ittc_spwes_waveamplitude(omega, domega, hs, wave_amplitude) 11th-ITTC (1966) 单参数波能谱模型计算频段有义波幅\nITTC single-parameter wave energy spectrum Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omega 波浪角频率, rad/s real(kind=rk), intent(in) :: domega 频率间隔, rad/s real(kind=rk), intent(in) :: hs 有义波高, m real(kind=rk), intent(out) :: wave_amplitude 频段有义波幅, m Contents Source Code ittc_spwes_waveamplitude Source Code pure subroutine ittc_spwes_waveamplitude ( omega , domega , hs , wave_amplitude ) real ( kind = rk ), intent ( in ) :: omega !! 波浪角频率, rad/s real ( kind = rk ), intent ( in ) :: domega !! 频率间隔, rad/s real ( kind = rk ), intent ( in ) :: hs !! 有义波高, m real ( kind = rk ), intent ( out ) :: wave_amplitude !! 频段有义波幅, m real ( kind = rk ) :: s real ( kind = rk ), parameter :: a = 8.1e-3_rk * g ** 2 associate ( b => 3.11_rk / hs ** 2 ) s = a * exp ( - b / omega ** 4 ) / omega ** 5 wave_amplitude = sqrt ( 2 * s * domega ) ! A = sqrt(2*S_\\omega*d\\omega) end associate end subroutine ittc_spwes_waveamplitude","tags":"","loc":"proc/ittc_spwes_waveamplitude.html"},{"title":"ccwes_waveamplitude – Seakeeping","text":"public pure subroutine ccwes_waveamplitude(omega, domega, hs, wave_amplitude) 中国沿海波能谱模型计算频段有义波幅\nChina Coastal Wave Energy Spectrum Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omega 波浪角频率, rad/s real(kind=rk), intent(in) :: domega 频率间隔, rad/s real(kind=rk), intent(in) :: hs 有义波高, m real(kind=rk), intent(out) :: wave_amplitude 频段有义波幅, m Contents Source Code ccwes_waveamplitude Source Code pure subroutine ccwes_waveamplitude ( omega , domega , hs , wave_amplitude ) real ( kind = rk ), intent ( in ) :: omega !! 波浪角频率, rad/s real ( kind = rk ), intent ( in ) :: domega !! 频率间隔, rad/s real ( kind = rk ), intent ( in ) :: hs !! 有义波高, m real ( kind = rk ), intent ( out ) :: wave_amplitude !! 频段有义波幅, m real ( kind = rk ) :: s associate ( u => 6.28_rk * sqrt ( hs )) s = 0.74_rk * exp ( - ( g / ( u * omega )) ** 2 ) / omega ** 5 wave_amplitude = sqrt ( 2 * s * domega ) ! A = sqrt(2*S_\\omega*d\\omega) end associate end subroutine ccwes_waveamplitude","tags":"","loc":"proc/ccwes_waveamplitude.html"},{"title":"hsp – Seakeeping","text":"public pure function hsp(rho, h) result(p) 静水压 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: rho 水密度 [kg/m&#94;3] real(kind=sk_real_kind), intent(in) :: h 水深 [m] Return Value real(kind=sk_real_kind) Contents","tags":"","loc":"proc/hsp.html"},{"title":"TPC – Seakeeping","text":"public elemental function TPC(rho, Aw) 每厘米吃水吨数 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: rho 水密度 real(kind=sk_real_kind), intent(in) :: Aw 水线面面积 Return Value real(kind=sk_real_kind) Contents","tags":"","loc":"proc/tpc.html"},{"title":"heron_formula – Seakeeping","text":"public pure function heron_formula(a, b, c) result(s) 海伦公式计算三角形面积 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a 三边长 (m) real(kind=sk_real_kind), intent(in) :: b 三边长 (m) real(kind=sk_real_kind), intent(in) :: c 三边长 (m) Return Value real(kind=sk_real_kind) Contents","tags":"","loc":"proc/heron_formula.html"},{"title":"euler_formula – Seakeeping","text":"public elemental function euler_formula(x) 欧拉公式 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: x Return Value complex(kind=sk_real_kind) Contents","tags":"","loc":"proc/euler_formula.html"},{"title":"angle – Seakeeping","text":"public pure function angle(x, y) 计算两向量的夹角 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in), dimension(3) :: x 两向量 real(kind=sk_real_kind), intent(in), dimension(3) :: y 两向量 Return Value real(kind=sk_real_kind) Contents","tags":"","loc":"proc/angle.html"},{"title":"root_formula – Seakeeping","text":"public pure subroutine root_formula(a, b, c, x1, x2) 一元二次方程求根公式 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a real(kind=sk_real_kind), intent(in) :: b real(kind=sk_real_kind), intent(in) :: c real(kind=sk_real_kind), intent(out), optional :: x1 real(kind=sk_real_kind), intent(out), optional :: x2 Contents Source Code root_formula Source Code pure subroutine root_formula ( a , b , c , x1 , x2 ) real ( kind = sk_real_kind ), intent ( in ) :: a , b , c real ( kind = sk_real_kind ), intent ( out ), optional :: x1 , x2 if ( b * b - 4 * a * c < 0 ) return if ( a > 0 ) then if ( present ( x1 )) x1 = ( - b - sqrt ( b * b - 4 * a * c )) / ( 2 * a ) if ( present ( x2 )) x2 = ( - b + sqrt ( b * b - 4 * a * c )) / ( 2 * a ) else if ( present ( x1 )) x1 = ( - b + sqrt ( b * b - 4 * a * c )) / ( 2 * a ) if ( present ( x2 )) x2 = ( - b - sqrt ( b * b - 4 * a * c )) / ( 2 * a ) end if end subroutine root_formula","tags":"","loc":"proc/root_formula.html"},{"title":"AMPD – Seakeeping","text":"public pure function AMPD(data, extend) result(location) Automatic multiscale-based peak detection (AMPD) 峰值查找算法 Note - 由于移动窗体宽度的存在，序列两端的峰值不被查找，如果需要被查找需要填充最小值，extend = T\n- 暂无法实时查找\n- 查询谷值，可将信号翻转后再查找 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: data (:) Input data 数据 logical, intent(in), optional :: extend Extend data width to get two end peaks 是否增强数据宽度以获取两端最大峰值 Return Value integer, allocatable, (:) Peak position 峰值位置 Contents Source Code AMPD Source Code pure function AMPD ( data , extend ) result ( location ) real ( sk_real_kind ), intent ( in ) :: data (:) !! Input data <br> !! 数据 logical , intent ( in ), optional :: extend !! Extend data width to get two end peaks <br> !! 是否增强数据宽度以获取两端最大峰值 integer , allocatable :: location (:) !! Peak position <br> !! 峰值位置 integer :: L , N , k , i , row_sum , min_index , extend_size integer , allocatable :: arr_row_sum (:) integer , allocatable :: p_data (:) logical :: extend_ real ( sk_real_kind ), allocatable :: data_ (:) if ( present ( extend )) then extend_ = extend else extend_ = . false . end if ! 确定最佳窗体宽度 N = size ( data ) L = N / 2 + 1 allocate ( arr_row_sum ( L )) do k = 1 , L row_sum = 0 do i = k , N - k if ( i - k == 0 . or . i + k == N + 1 ) cycle if ( data ( i ) > data ( i - k ) . and . data ( i ) > data ( i + k )) row_sum = row_sum - 1 end do arr_row_sum ( k ) = row_sum end do min_index = minloc ( arr_row_sum , dim = 1 ) ! 通过最小值确定最佳窗体宽度，显著提升峰值特征，方便查找峰值 ! 查找峰值 if ( extend_ ) then extend_size = min_index + 1 else extend_size = 0 end if N = N + extend_size * 2 allocate ( p_data ( N ), source = 0 ) if ( extend_ ) then allocate ( data_ ( N )) associate ( min => minval ( data , dim = 1 )) data_ (: extend_size ) = min data_ ( extend_size + 1 : N - extend_size ) = data (:) data_ ( N - extend_size + 1 :) = min end associate else allocate ( data_ ( N ), source = data ) end if do k = 1 , min_index + 1 do i = k , N - k if ( i - k == 0 . or . i + k == N + 1 ) cycle if ( data_ ( i ) > data_ ( i - k ) . and . data_ ( i ) > data_ ( i + k )) p_data ( i ) = p_data ( i ) + 1 end do end do allocate ( location ( 0 )) do i = 1 , N if ( p_data ( i ) == min_index ) location = [ location , i ] end do if ( extend_ ) location = location - extend_size end function AMPD","tags":"","loc":"proc/ampd.html"},{"title":"distance – Seakeeping","text":"public pure function distance(a) result(dis) Distance between two points 两点间距离, Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) Return Value real(kind=sk_real_kind) Contents Source Code distance Source Code pure function distance ( a ) result ( dis ) real ( sk_real_kind ), intent ( in ) :: a ( 3 ) real ( sk_real_kind ) :: dis dis = sqrt ( a ( 1 ) * a ( 1 ) + a ( 2 ) * a ( 2 ) + a ( 3 ) * a ( 3 )) end function distance","tags":"","loc":"proc/distance.html"},{"title":"unitize – Seakeeping","text":"public pure function unitize(x) result(y) Unitize a vector 单位化向量 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in), dimension(3) :: x Return Value real(kind=sk_real_kind), dimension(3) Contents Source Code unitize Source Code pure function unitize ( x ) result ( y ) real ( sk_real_kind ), intent ( in ), dimension ( 3 ) :: x real ( sk_real_kind ), dimension ( 3 ) :: y y = x / distance ( x ) end function unitize","tags":"","loc":"proc/unitize.html"},{"title":"centroid – Seakeeping","text":"public interface centroid Contents Module Procedures centroid3l centroid4l Module Procedures private pure function centroid3l(a, b, c) result(cen) Centroid of a triangle 三角形形心 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) Return Value real(kind=sk_real_kind), (3) private pure function centroid4l(a, b, c, d) result(cen) Centroid of a quadrilateral 四边形形心 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) real(kind=sk_real_kind), intent(in) :: d (3) Return Value real(kind=sk_real_kind), (3)","tags":"","loc":"interface/centroid.html"},{"title":"area – Seakeeping","text":"public interface area Contents Module Procedures area3l area4l Module Procedures private pure function area3l(a, b, c) result(area) Area of a triangle 三角形面积 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) Return Value real(kind=sk_real_kind) private pure function area4l(a, b, c, d) result(area) Area of a quadrilateral 四边形面积 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) real(kind=sk_real_kind), intent(in) :: d (3) Return Value real(kind=sk_real_kind)","tags":"","loc":"interface/area.html"},{"title":"leapfrog – Seakeeping","text":"public  subroutine leapfrog(func, x, v, a, t, m, dt, n) 速度比位移、加速度快半步长，本例程仅用作力学求解，求解一段时间内的力学变化，并更新时间 Arguments Type Intent Optional Attributes Name real :: func real(kind=rk), intent(inout), dimension(*) :: x real(kind=rk), intent(inout), dimension(*) :: v real(kind=rk), intent(inout), dimension(*) :: a real(kind=rk), intent(inout) :: t integer, intent(in) :: m real(kind=rk), intent(in) :: dt integer, intent(in) :: n Contents Source Code leapfrog Source Code subroutine leapfrog ( func , x , v , a , t , m , dt , n ) external :: func real ( kind = rk ), intent ( inout ), dimension ( * ) :: x , v , a real ( kind = rk ), intent ( inout ) :: t integer , intent ( in ) :: m real ( kind = rk ), intent ( in ) :: dt integer , intent ( in ) :: n real ( kind = rk ) :: t0 , vtmp ( n ) integer :: i do i = 1 , m t0 = t + dt * i x (: n ) = x (: n ) + v (: n ) * dt vtmp = v (: n ) + a (: n ) * dt / 2 call func ( t , x , vtmp , a ) v (: n ) = v (: n ) + a (: n ) * dt end do if ( m > 0 ) t = t0 end subroutine leapfrog","tags":"","loc":"proc/leapfrog.html"},{"title":"leapfrog_init – Seakeeping","text":"public  subroutine leapfrog_init(func, x0, v0, a0, t0, dt, n) 初始化leapfrog算法，初始化加速度及推进速度半步长 Arguments Type Intent Optional Attributes Name real :: func real(kind=rk), intent(in), dimension(*) :: x0 real(kind=rk), intent(inout), dimension(*) :: v0 real(kind=rk), intent(out), dimension(*) :: a0 real(kind=rk), intent(in) :: t0 real(kind=rk), intent(in) :: dt integer, intent(in) :: n Contents Source Code leapfrog_init Source Code subroutine leapfrog_init ( func , x0 , v0 , a0 , t0 , dt , n ) external :: func real ( kind = rk ), intent ( in ), dimension ( * ) :: x0 real ( kind = rk ), intent ( inout ), dimension ( * ) :: v0 real ( kind = rk ), intent ( out ), dimension ( * ) :: a0 real ( kind = rk ), intent ( in ) :: t0 , dt integer , intent ( in ) :: n call func ( t0 , x0 , v0 , a0 ) v0 (: n ) = v0 (: n ) + a0 (: n ) * dt / 2 end subroutine leapfrog_init","tags":"","loc":"proc/leapfrog_init.html"},{"title":"leapfrog_final – Seakeeping","text":"public  subroutine leapfrog_final(v0, a0, dt, n) 速度后退半步长，使其与位移、加速度同步 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout), dimension(*) :: v0 real(kind=rk), intent(in), dimension(*) :: a0 real(kind=rk), intent(in) :: dt integer, intent(in) :: n Contents Source Code leapfrog_final Source Code subroutine leapfrog_final ( v0 , a0 , dt , n ) real ( kind = rk ), intent ( inout ), dimension ( * ) :: v0 real ( kind = rk ), intent ( in ), dimension ( * ) :: a0 real ( kind = rk ), intent ( in ) :: dt integer , intent ( in ) :: n v0 (: n ) = v0 (: n ) - a0 (: n ) * dt / 2 end subroutine leapfrog_final","tags":"","loc":"proc/leapfrog_final.html"},{"title":"seakeeping_wave – Seakeeping","text":"Seakeeping wave theory 耐波性波浪理论 参考 船舶原理（上） 如何让水中涟漪变成拍岸巨浪？水面波的形成原因和增强原理. Uses seakeeping_constants seakeeping_kinds Contents Functions k01 k02 we wlr wf wenergy zeta vdeep Subroutines ittc_tpwes_waveamplitude ittc_spwes_waveamplitude ccwes_waveamplitude Functions public elemental function k01 (w) result(k0) Wave number from wave frequency 波频率计算波数 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: w Return Value real(kind=rk) public elemental function k02 (l) result(k0) Wave number from wave length 波长计算波数 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: l Return Value real(kind=rk) public elemental function we (w, v, deg) Encountered wave frequency 遭遇波频率 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: w Wave frequency 波频率 real(kind=rk), intent(in) :: v Ship speed 船舶速度 real(kind=rk), intent(in), optional :: deg Ship heading 船舶航向 Return Value real(kind=rk) public elemental function wlr (w, l) Wavelength to length ratio 波长与船长比 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: w Wave frequency 波频率 real(kind=rk), intent(in) :: l Ship length 船舶特征长度 Return Value real(kind=rk) public elemental function wf (wlr, l) Wave frequency from wlr 由波长与船长比计算波频率 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: wlr Wavelength to length ratio 波长与船长比 real(kind=rk), intent(in) :: l Ship length 船舶特征长度 Return Value real(kind=rk) public elemental function wenergy (rho, a) Wave energy 波能：动能 + 势能, Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho Water density 水密度 real(kind=rk), intent(in) :: a Wave amplitude 波幅 Return Value real(kind=rk) public pure function zeta (k, x, y, w, t, beta, phase) 单位波幅： \\zeta = \\sin(kx\\cos\\beta + ky\\sin\\beta + \\omega t + phase)  Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: k real(kind=rk), intent(in) :: x real(kind=rk), intent(in) :: y real(kind=rk), intent(in) :: w real(kind=rk), intent(in) :: t real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: phase Return Value real(kind=rk) public pure function vdeep (lambda) 深水波波速 Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: lambda Return Value real(kind=rk) Subroutines public pure subroutine ittc_tpwes_waveamplitude (omega, domega, t1, hs, wave_amplitude) 12th-ITTC (1969) 双参数波能谱模型计算频段有义波幅\nITTC two-parameter wave energy spectrum Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omega 波浪角频率, rad/s real(kind=rk), intent(in) :: domega 频率间隔, rad/s real(kind=rk), intent(in) :: t1 平均周期, s, T1 = 2 pi m0/m1 real(kind=rk), intent(in) :: hs 有义波高, m real(kind=rk), intent(out) :: wave_amplitude 频段有义波幅, m public pure subroutine ittc_spwes_waveamplitude (omega, domega, hs, wave_amplitude) 11th-ITTC (1966) 单参数波能谱模型计算频段有义波幅\nITTC single-parameter wave energy spectrum Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omega 波浪角频率, rad/s real(kind=rk), intent(in) :: domega 频率间隔, rad/s real(kind=rk), intent(in) :: hs 有义波高, m real(kind=rk), intent(out) :: wave_amplitude 频段有义波幅, m public pure subroutine ccwes_waveamplitude (omega, domega, hs, wave_amplitude) 中国沿海波能谱模型计算频段有义波幅\nChina Coastal Wave Energy Spectrum Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omega 波浪角频率, rad/s real(kind=rk), intent(in) :: domega 频率间隔, rad/s real(kind=rk), intent(in) :: hs 有义波高, m real(kind=rk), intent(out) :: wave_amplitude 频段有义波幅, m","tags":"","loc":"module/seakeeping_wave.html"},{"title":"seakeeping_collection_vector – Seakeeping","text":"Vector 泛型向量 (通用但效率稍低) Contents Derived Types vector Derived Types type, public :: vector Vector 泛型向量 Components Type Visibility Attributes Name Initial integer, public :: len = 0 有效向量长度 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init Subroutine procedure\n                    ,                  public\n,                   :: pop Subroutine procedure\n                    ,                  public\n,                   :: push Subroutine procedure\n                    ,                  public\n,                   :: set Subroutine procedure\n                    ,                  public\n,                   :: get Subroutine procedure\n                    ,                  public\n,                   :: clear Subroutine","tags":"","loc":"module/seakeeping_collection_vector.html"},{"title":"seakeeping_statics – Seakeeping","text":"耐波性静力学 Uses seakeeping_constants seakeeping_kinds Contents Functions hsp TPC Functions public pure function hsp (rho, h) result(p) 静水压 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: rho 水密度 [kg/m&#94;3] real(kind=sk_real_kind), intent(in) :: h 水深 [m] Return Value real(kind=sk_real_kind) public elemental function TPC (rho, Aw) 每厘米吃水吨数 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: rho 水密度 real(kind=sk_real_kind), intent(in) :: Aw 水线面面积 Return Value real(kind=sk_real_kind)","tags":"","loc":"module/seakeeping_statics.html"},{"title":"seakeeping_collection_stack_real – Seakeeping","text":"stack 实数队列 Uses seakeeping_kinds Contents Derived Types stack_real stack_real_iterator Derived Types type, public :: stack_real 堆栈 Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the stack_real Type-Bound Procedures procedure\n                    ,                  public\n,                   :: push =>\n                    stack_real_push Subroutine procedure\n                    ,                  public\n,                   :: pop =>\n                    stack_real_pop Subroutine procedure\n                    ,                  public\n,                   :: iterator Function procedure\n                    ,                  public\n,                   :: clear =>\n                    stack_real_clear Subroutine type, public :: stack_real_iterator 迭代器 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    stack_real_iterator_next Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    stack_real_iterator_clear Subroutine","tags":"","loc":"module/seakeeping_collection_stack_real.html"},{"title":"seakeeping_module – Seakeeping","text":"Seakeeping 耐波性模块 Uses seakeeping_constants seakeeping_math seakeeping_leapfrog seakeeping_kinds seakeeping_geometry seakeeping_wave seakeeping_collection seakeeping_tsa seakeeping_statics Contents None","tags":"","loc":"module/seakeeping_module.html"},{"title":"seakeeping_collection_vector_real – Seakeeping","text":"Vector 实数向量 Uses seakeeping_kinds Contents Derived Types vector_real Derived Types type, public :: vector_real Vector_real 实数向量 Components Type Visibility Attributes Name Initial integer, public :: len = 0 有效向量长度 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init Subroutine procedure\n                    ,                  public\n,                   :: pop Subroutine procedure\n                    ,                  public\n,                   :: push Subroutine procedure\n                    ,                  public\n,                   :: set Subroutine procedure\n                    ,                  public\n,                   :: get Subroutine procedure\n                    ,                  public\n,                   :: clear Subroutine","tags":"","loc":"module/seakeeping_collection_vector_real.html"},{"title":"seakeeping_math – Seakeeping","text":"耐波性数学 Uses seakeeping_kinds Contents Functions heron_formula euler_formula angle Subroutines root_formula Functions public pure function heron_formula (a, b, c) result(s) 海伦公式计算三角形面积 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a 三边长 (m) real(kind=sk_real_kind), intent(in) :: b 三边长 (m) real(kind=sk_real_kind), intent(in) :: c 三边长 (m) Return Value real(kind=sk_real_kind) public elemental function euler_formula (x) 欧拉公式 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: x Return Value complex(kind=sk_real_kind) public pure function angle (x, y) 计算两向量的夹角 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in), dimension(3) :: x 两向量 real(kind=sk_real_kind), intent(in), dimension(3) :: y 两向量 Return Value real(kind=sk_real_kind) Subroutines public pure subroutine root_formula (a, b, c, x1, x2) 一元二次方程求根公式 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a real(kind=sk_real_kind), intent(in) :: b real(kind=sk_real_kind), intent(in) :: c real(kind=sk_real_kind), intent(out), optional :: x1 real(kind=sk_real_kind), intent(out), optional :: x2","tags":"","loc":"module/seakeeping_math.html"},{"title":"seakeeping_collection_queue – Seakeeping","text":"Queue 泛型队列 (通用但效率稍低) Contents Derived Types queue queue_iterator Derived Types type, public :: queue 队列 Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the queue Type-Bound Procedures procedure\n                    ,                  public\n,                   :: enqueue =>\n                    queue_enqueue Subroutine procedure\n                    ,                  public\n,                   :: dequeue =>\n                    queue_dequeue Subroutine procedure\n                    ,                  public\n,                   :: iterator Function procedure\n                    ,                  public\n,                   :: clear =>\n                    queue_clear Subroutine type, public :: queue_iterator 迭代器 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    queue_iterator_next Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    queue_iterator_clear Subroutine","tags":"","loc":"module/seakeeping_collection_queue.html"},{"title":"seakeeping_collection_stack – Seakeeping","text":"stack 泛型堆栈 (通用但效率稍低) Contents Derived Types stack stack_iterator Derived Types type, public :: stack 堆栈 Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the stack Type-Bound Procedures procedure\n                    ,                  public\n,                   :: push =>\n                    stack_push Subroutine procedure\n                    ,                  public\n,                   :: pop =>\n                    stack_pop Subroutine procedure\n                    ,                  public\n,                   :: iterator Function procedure\n                    ,                  public\n,                   :: clear =>\n                    stack_clear Subroutine type, public :: stack_iterator 迭代器 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    stack_iterator_next Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    stack_iterator_clear Subroutine","tags":"","loc":"module/seakeeping_collection_stack.html"},{"title":"seakeeping_collection_queue_real – Seakeeping","text":"Queue 实数队列 Uses seakeeping_kinds Contents Derived Types queue_real queue_real_iterator Derived Types type, public :: queue_real 队列 Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the queue Type-Bound Procedures procedure\n                    ,                  public\n,                   :: enqueue =>\n                    queue_enqueue Subroutine procedure\n                    ,                  public\n,                   :: dequeue =>\n                    queue_dequeue Subroutine procedure\n                    ,                  public\n,                   :: iterator Function procedure\n                    ,                  public\n,                   :: clear =>\n                    queue_clear Subroutine type, public :: queue_real_iterator 迭代器 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    queue_iterator_next Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    queue_iterator_clear Subroutine","tags":"","loc":"module/seakeeping_collection_queue_real.html"},{"title":"seakeeping_constants – Seakeeping","text":"耐波性常数 Uses seakeeping_kinds Contents Variables pi pi2 g rho_water rho_air p_atm kn2ms ms2kn Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: pi = acos(-1.0_rk) real(kind=rk), public, parameter :: pi2 = 2.0_rk*pi real(kind=rk), public, parameter :: g = 9.80665_rk real(kind=rk), public, parameter :: rho_water (2) = [1000.0_rk, 1025.0_rk] real(kind=rk), public, parameter :: rho_air = 1.205_rk real(kind=rk), public, parameter :: p_atm = 101325.0_rk real(kind=rk), public, parameter :: kn2ms = 1852.0_rk/3600.0_rk real(kind=rk), public, parameter :: ms2kn = 3600.0_rk/1852.0_rk","tags":"","loc":"module/seakeeping_constants.html"},{"title":"seakeeping_collection – Seakeeping","text":"数据容器, 旨在灵活存储数据 Uses seakeeping_collection_vector seakeeping_collection_queue_real seakeeping_collection_vector_int seakeeping_collection_stack seakeeping_collection_queue seakeeping_collection_vector_real seakeeping_collection_queue_int seakeeping_collection_stack_int seakeeping_collection_stack_real Contents None","tags":"","loc":"module/seakeeping_collection.html"},{"title":"seakeeping_collection_stack_int – Seakeeping","text":"stack 整型堆栈 Contents Derived Types stack_int stack_int_iterator Derived Types type, public :: stack_int 堆栈 Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the stack_int Type-Bound Procedures procedure\n                    ,                  public\n,                   :: push =>\n                    stack_int_push Subroutine procedure\n                    ,                  public\n,                   :: pop =>\n                    stack_int_pop Subroutine procedure\n                    ,                  public\n,                   :: iterator Function procedure\n                    ,                  public\n,                   :: clear =>\n                    stack_int_clear Subroutine type, public :: stack_int_iterator 迭代器 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    stack_int_iterator_next Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    stack_int_iterator_clear Subroutine","tags":"","loc":"module/seakeeping_collection_stack_int.html"},{"title":"seakeeping_tsa – Seakeeping","text":"Seakeeping time series analysis 耐波性时间序列分析 Uses seakeeping_constants seakeeping_kinds Contents Functions AMPD Functions public pure function AMPD (data, extend) result(location) Automatic multiscale-based peak detection (AMPD) 峰值查找算法 Read more… Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: data (:) Input data 数据 logical, intent(in), optional :: extend Extend data width to get two end peaks 是否增强数据宽度以获取两端最大峰值 Return Value integer, allocatable, (:) Peak position 峰值位置","tags":"","loc":"module/seakeeping_tsa.html"},{"title":"seakeeping_collection_vector_int – Seakeeping","text":"Vector 整型向量 Uses seakeeping_kinds Contents Derived Types vector_int Derived Types type, public :: vector_int Vector_int 整型向量 Components Type Visibility Attributes Name Initial integer, public :: len = 0 有效向量长度 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init Subroutine procedure\n                    ,                  public\n,                   :: pop Subroutine procedure\n                    ,                  public\n,                   :: push Subroutine procedure\n                    ,                  public\n,                   :: set Subroutine procedure\n                    ,                  public\n,                   :: get Subroutine procedure\n                    ,                  public\n,                   :: clear Subroutine","tags":"","loc":"module/seakeeping_collection_vector_int.html"},{"title":"seakeeping_geometry – Seakeeping","text":"Seakeeping geometry 耐波性几何学 Uses seakeeping_math seakeeping_kinds Contents Interfaces centroid area Functions distance unitize Interfaces public        interface centroid private pure function centroid3l(a, b, c) result(cen) Centroid of a triangle 三角形形心 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) Return Value real(kind=sk_real_kind), (3) private pure function centroid4l(a, b, c, d) result(cen) Centroid of a quadrilateral 四边形形心 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) real(kind=sk_real_kind), intent(in) :: d (3) Return Value real(kind=sk_real_kind), (3) public        interface area private pure function area3l(a, b, c) result(area) Area of a triangle 三角形面积 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) Return Value real(kind=sk_real_kind) private pure function area4l(a, b, c, d) result(area) Area of a quadrilateral 四边形面积 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) real(kind=sk_real_kind), intent(in) :: b (3) real(kind=sk_real_kind), intent(in) :: c (3) real(kind=sk_real_kind), intent(in) :: d (3) Return Value real(kind=sk_real_kind) Functions public pure function distance (a) result(dis) Distance between two points 两点间距离, Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in) :: a (3) Return Value real(kind=sk_real_kind) public pure function unitize (x) result(y) Unitize a vector 单位化向量 Arguments Type Intent Optional Attributes Name real(kind=sk_real_kind), intent(in), dimension(3) :: x Return Value real(kind=sk_real_kind), dimension(3)","tags":"","loc":"module/seakeeping_geometry.html"},{"title":"seakeeping_leapfrog – Seakeeping","text":"leapfrog 算法计算量相对较少，精度适中，可用于力学求解 Uses seakeeping_kinds Contents Subroutines leapfrog leapfrog_init leapfrog_final Subroutines public  subroutine leapfrog (func, x, v, a, t, m, dt, n) 速度比位移、加速度快半步长，本例程仅用作力学求解，求解一段时间内的力学变化，并更新时间 Arguments Type Intent Optional Attributes Name real :: func real(kind=rk), intent(inout), dimension(*) :: x real(kind=rk), intent(inout), dimension(*) :: v real(kind=rk), intent(inout), dimension(*) :: a real(kind=rk), intent(inout) :: t integer, intent(in) :: m real(kind=rk), intent(in) :: dt integer, intent(in) :: n public  subroutine leapfrog_init (func, x0, v0, a0, t0, dt, n) 初始化leapfrog算法，初始化加速度及推进速度半步长 Arguments Type Intent Optional Attributes Name real :: func real(kind=rk), intent(in), dimension(*) :: x0 real(kind=rk), intent(inout), dimension(*) :: v0 real(kind=rk), intent(out), dimension(*) :: a0 real(kind=rk), intent(in) :: t0 real(kind=rk), intent(in) :: dt integer, intent(in) :: n public  subroutine leapfrog_final (v0, a0, dt, n) 速度后退半步长，使其与位移、加速度同步 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout), dimension(*) :: v0 real(kind=rk), intent(in), dimension(*) :: a0 real(kind=rk), intent(in) :: dt integer, intent(in) :: n","tags":"","loc":"module/seakeeping_leapfrog.html"},{"title":"seakeeping_kinds – Seakeeping","text":"Seakeeping kinds 耐波性例程浮点数、复数精度 Contents Variables sk_real_kind sk_real_kind Variables Type Visibility Attributes Name Initial integer, public, parameter :: sk_real_kind = kind(0.0d0) integer, public, parameter :: sk_real_kind = kind(0.0)","tags":"","loc":"module/seakeeping_kinds.html"},{"title":"seakeeping_collection_queue_int – Seakeeping","text":"Queue 整型队列 Contents Derived Types queue_int queue_int_iterator Derived Types type, public :: queue_int 队列 Components Type Visibility Attributes Name Initial integer, public :: len = 0 number of nodes in the queue Type-Bound Procedures procedure\n                    ,                  public\n,                   :: enqueue =>\n                    queue_enqueue Subroutine procedure\n                    ,                  public\n,                   :: dequeue =>\n                    queue_dequeue Subroutine procedure\n                    ,                  public\n,                   :: iterator Function procedure\n                    ,                  public\n,                   :: clear =>\n                    queue_clear Subroutine type, public :: queue_int_iterator 迭代器 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    queue_iterator_next Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    queue_iterator_clear Subroutine","tags":"","loc":"module/seakeeping_collection_queue_int.html"},{"title":"seakeeping_wave.f90 – Seakeeping","text":"Contents Modules seakeeping_wave Source Code seakeeping_wave.f90 Source Code !> author: 左志华 !> date: 2022-09-16 !> !> Seakeeping wave theory <br> !> 耐波性波浪理论 !>### 参考 !> 1. 船舶原理（上）<br> !> 2. 如何让水中涟漪变成拍岸巨浪？水面波的形成原因和增强原理. module seakeeping_wave use seakeeping_kinds , only : rk => sk_real_kind use seakeeping_constants , only : g , Pi , pi2 implicit none private public :: k01 , k02 , we , wlr , wf , wenergy , zeta , vdeep , & ittc_tpwes_waveamplitude , ccwes_waveamplitude , ittc_spwes_waveamplitude contains !> Wave number from wave frequency <br> !> 波频率计算波数 elemental real ( rk ) function k01 ( w ) result ( k0 ) real ( rk ), intent ( in ) :: w k0 = w * w / g end function k01 !> Wave number from wave length <br> !> 波长计算波数 elemental real ( rk ) function k02 ( l ) result ( k0 ) real ( rk ), intent ( in ) :: l k0 = pi2 / l end function k02 !> Encountered wave frequency <br> !> 遭遇波频率 elemental real ( rk ) function we ( w , v , deg ) real ( rk ), intent ( in ) :: w !! Wave frequency <br> !! 波频率 real ( rk ), intent ( in ) :: v !! Ship speed <br> !! 船舶速度 real ( rk ), intent ( in ), optional :: deg !! Ship heading <br> !! 船舶航向 if ( present ( deg )) then we = w + k01 ( w ) * v * cos ( deg ) else we = w + k01 ( w ) * v end if end function we !> Wavelength to length ratio <br> !> 波长与船长比 elemental real ( rk ) function wlr ( w , l ) real ( rk ), intent ( in ) :: w !! Wave frequency <br> !! 波频率 real ( rk ), intent ( in ) :: l !! Ship length <br> !! 船舶特征长度 wlr = pi2 / ( k01 ( w ) * l ) end function wlr !> Wave frequency from wlr <br> !> 由波长与船长比计算波频率 elemental real ( rk ) function wf ( wlr , l ) real ( rk ), intent ( in ) :: wlr !! Wavelength to length ratio <br> !! 波长与船长比 real ( rk ), intent ( in ) :: l !! Ship length <br> !! 船舶特征长度 wf = sqrt ( g * k02 ( wlr * l )) end function wf !> Wave energy <br> !> 波能：动能 + 势能,  energy = 0.5*ρ*A&#94;2*g  elemental real ( rk ) function wenergy ( rho , a ) real ( rk ), intent ( in ) :: rho !! Water density <br> !! 水密度 real ( rk ), intent ( in ) :: a !! Wave amplitude <br> !! 波幅 wenergy = rho * g * a * a / 2 end function wenergy !> 单位波幅：\\ \\zeta = \\sin(kx\\cos\\beta + ky\\sin\\beta + \\omega t + phase) \\ real ( rk ) pure function zeta ( k , x , y , w , t , beta , phase ) real ( rk ), intent ( in ) :: k , x , y , w , t , beta , phase zeta = sin ( k * x * cos ( beta ) + k * y * sin ( beta ) + w * t + phase ) end function zeta !> 深水波波速  v = \\sqrt{\\frac{g\\lambda}{2\\pi}}  !>@note 确保水深大于半波长，造波机多次前后移动制造深水波，波长越大的后波将追赶前波， !> 最终水面波可叠加形成一条大浪 real ( rk ) pure function vdeep ( lambda ) real ( rk ), intent ( in ) :: lambda vdeep = sqrt ( g * lambda / ( pi2 )) end function vdeep !> 12th-ITTC (1969) 双参数波能谱模型计算频段有义波幅 !> ITTC two-parameter wave energy spectrum pure subroutine ittc_tpwes_waveamplitude ( omega , domega , t1 , hs , wave_amplitude ) real ( kind = rk ), intent ( in ) :: omega !! 波浪角频率, rad/s real ( kind = rk ), intent ( in ) :: domega !! 频率间隔, rad/s real ( kind = rk ), intent ( in ) :: t1 !! 平均周期, s, T1 = 2*pi*m0/m1 real ( kind = rk ), intent ( in ) :: hs !! 有义波高, m real ( kind = rk ), intent ( out ) :: wave_amplitude !! 频段有义波幅, m real ( kind = rk ) :: s associate ( a => 173 * hs ** 2 / t1 ** 4 , b => 691 / t1 ** 4 ) s = a * exp ( - b / omega ** 4 ) / omega ** 5 wave_amplitude = sqrt ( 2 * s * domega ) ! A = sqrt(2*S_\\omega*d\\omega) end associate end subroutine ittc_tpwes_waveamplitude !> 11th-ITTC (1966) 单参数波能谱模型计算频段有义波幅 !> ITTC single-parameter wave energy spectrum pure subroutine ittc_spwes_waveamplitude ( omega , domega , hs , wave_amplitude ) real ( kind = rk ), intent ( in ) :: omega !! 波浪角频率, rad/s real ( kind = rk ), intent ( in ) :: domega !! 频率间隔, rad/s real ( kind = rk ), intent ( in ) :: hs !! 有义波高, m real ( kind = rk ), intent ( out ) :: wave_amplitude !! 频段有义波幅, m real ( kind = rk ) :: s real ( kind = rk ), parameter :: a = 8.1e-3_rk * g ** 2 associate ( b => 3.11_rk / hs ** 2 ) s = a * exp ( - b / omega ** 4 ) / omega ** 5 wave_amplitude = sqrt ( 2 * s * domega ) ! A = sqrt(2*S_\\omega*d\\omega) end associate end subroutine ittc_spwes_waveamplitude !> 中国沿海波能谱模型计算频段有义波幅 !> China Coastal Wave Energy Spectrum pure subroutine ccwes_waveamplitude ( omega , domega , hs , wave_amplitude ) real ( kind = rk ), intent ( in ) :: omega !! 波浪角频率, rad/s real ( kind = rk ), intent ( in ) :: domega !! 频率间隔, rad/s real ( kind = rk ), intent ( in ) :: hs !! 有义波高, m real ( kind = rk ), intent ( out ) :: wave_amplitude !! 频段有义波幅, m real ( kind = rk ) :: s associate ( u => 6.28_rk * sqrt ( hs )) s = 0.74_rk * exp ( - ( g / ( u * omega )) ** 2 ) / omega ** 5 wave_amplitude = sqrt ( 2 * s * domega ) ! A = sqrt(2*S_\\omega*d\\omega) end associate end subroutine ccwes_waveamplitude end module seakeeping_wave","tags":"","loc":"sourcefile/seakeeping_wave.f90.html"},{"title":"seakeeping_collection_vector.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_vector Source Code seakeeping_collection_vector.f90 Source Code !> Vector 泛型向量 (通用但效率稍低) module seakeeping_collection_vector implicit none private public :: vector !> 节点 type node private class ( * ), allocatable :: item !! 泛型数据 end type node !> Vector 泛型向量 type vector private integer , public :: len = 0 !! 有效向量长度 type ( node ), allocatable :: items (:) !! 泛型数组 contains procedure :: init procedure :: push , pop procedure :: get , set procedure :: clear procedure , private :: extend end type vector contains !> 初始化向量 pure subroutine init ( self ) class ( vector ), intent ( inout ) :: self self % len = 0 if (. not . allocated ( self % items )) allocate ( self % items ( 256 )) end subroutine init !> 向量扩容 pure subroutine extend ( self ) class ( vector ), intent ( inout ) :: self type ( node ), allocatable :: tmp (:) intrinsic :: size allocate ( tmp ( size ( self % items ))) self % items = [ self % items , tmp ] end subroutine extend !> 向量压入 pure subroutine push ( self , item ) class ( vector ), intent ( inout ) :: self class ( * ), intent ( in ) :: item intrinsic :: size if ( self % len == size ( self % items )) call self % extend () self % len = self % len + 1 allocate ( self % items ( self % len )% item , source = item ) end subroutine push !> 向量弹出 subroutine pop ( self , item ) class ( vector ), intent ( inout ) :: self class ( * ), intent ( out ), optional , allocatable :: item if ( self % len == 0 ) return if ( present ( item )) then call move_alloc ( self % items ( self % len )% item , item ) else deallocate ( self % items ( self % len )% item ) end if self % len = self % len - 1 end subroutine pop !> 向量获取 subroutine get ( self , index , item ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: index class ( * ), intent ( out ), allocatable :: item if ( index < 1 . or . index > self % len ) return allocate ( item , source = self % items ( index )% item ) end subroutine get !> 向量设置 pure subroutine set ( self , index , item ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index class ( * ), intent ( in ) :: item if ( index < 1 . or . index > self % len ) return allocate ( self % items ( index )% item , source = item ) end subroutine set !> 向量清空 pure subroutine clear ( self ) class ( vector ), intent ( inout ) :: self deallocate ( self % items ) self % len = 0 end subroutine clear end module seakeeping_collection_vector","tags":"","loc":"sourcefile/seakeeping_collection_vector.f90.html"},{"title":"seakeeping_statics.f90 – Seakeeping","text":"Contents Modules seakeeping_statics Source Code seakeeping_statics.f90 Source Code !> 耐波性静力学 module seakeeping_statics use seakeeping_kinds use seakeeping_constants contains !> 静水压 pure real ( kind = sk_real_kind ) function hsp ( rho , h ) result ( p ) real ( kind = sk_real_kind ), intent ( in ) :: rho !! 水密度 [kg/m&#94;3] real ( kind = sk_real_kind ), intent ( in ) :: h !! 水深 [m] p = rho * g * h end function hsp !> 每厘米吃水吨数  TPC = rho*Aw/100  elemental real ( kind = sk_real_kind ) function TPC ( rho , Aw ) real ( kind = sk_real_kind ), intent ( in ) :: rho !! 水密度 real ( kind = sk_real_kind ), intent ( in ) :: Aw !! 水线面面积 TPC = rho * Aw / 100 end function TPC end module seakeeping_statics","tags":"","loc":"sourcefile/seakeeping_statics.f90.html"},{"title":"seakeeping_collection_stack_real.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_stack_real Source Code seakeeping_collection_stack_real.f90 Source Code !> stack 实数队列 module seakeeping_collection_stack_real use seakeeping_kinds , only : rk => sk_real_kind implicit none private public :: stack_real , stack_real_iterator !> 节点 type node private type ( node ), pointer :: prev => null () type ( node ), pointer :: next => null () real ( rk ) :: item !! content of the node contains procedure :: clear => node_clear end type node !> 堆栈 type stack_real private integer , public :: len = 0 !! number of nodes in the stack_real type ( node ), pointer :: head => null () !! head of the stack_real type ( node ), pointer :: tail => null () !! tail of the stack_real contains procedure :: push => stack_real_push procedure :: pop => stack_real_pop procedure :: iterator procedure :: clear => stack_real_clear end type stack_real !> 迭代器 type stack_real_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => stack_real_iterator_next procedure :: clear => stack_real_iterator_clear end type stack_real_iterator contains !> Initialize the node from a new item pure function init_node ( new_item ) result ( new_node ) real ( rk ), intent ( in ) :: new_item type ( node ) :: new_node new_node % item = new_item end function init_node !> Clear the node pure subroutine node_clear ( self ) class ( node ), intent ( inout ) :: self nullify ( self % prev ) nullify ( self % next ) end subroutine node_clear !> push an item to the stack_real pure subroutine stack_real_push ( self , item ) class ( stack_real ), intent ( inout ) :: self real ( rk ), intent ( in ) :: item if ( associated ( self % tail )) then allocate ( self % tail % next , source = init_node ( item )) self % tail % next % prev => self % tail self % tail => self % tail % next else allocate ( self % head , source = init_node ( item )) self % tail => self % head end if self % len = self % len + 1 end subroutine stack_real_push !> pop an item from the stack_real pure subroutine stack_real_pop ( self , item ) class ( stack_real ), intent ( inout ) :: self real ( rk ), intent ( out ), optional :: item type ( node ), pointer :: curr_node if ( associated ( self % tail )) then if ( present ( item )) then item = self % tail % item end if curr_node => self % tail self % tail => curr_node % prev self % len = self % len - 1 nullify ( curr_node % prev , curr_node % next ) deallocate ( curr_node ) if ( self % len == 0 ) then nullify ( self % head , self % tail ) end if end if end subroutine stack_real_pop !> Get an stack_real_iterator for the stack_real type ( stack_real_iterator ) function iterator ( self ) result ( iter ) class ( stack_real ), intent ( in ) :: self iter % ptr => self % head end function iterator !> Clear the stack_real pure subroutine stack_real_clear ( self ) class ( stack_real ), intent ( inout ) :: self type ( node ), pointer :: curr_node do while ( self % len > 0 ) curr_node => self % head if ( associated ( curr_node % next )) then nullify ( curr_node % next % prev ) self % head => self % head % next end if call curr_node % clear () deallocate ( curr_node ) self % len = self % len - 1 end do nullify ( self % head , self % tail ) end subroutine stack_real_clear !> Clear the stack_real_iterator pure subroutine stack_real_iterator_clear ( self ) class ( stack_real_iterator ), intent ( inout ) :: self nullify ( self % ptr ) end subroutine stack_real_iterator_clear !> Get the next item from the stack_real_iterator pure subroutine stack_real_iterator_next ( self , item ) class ( stack_real_iterator ), intent ( inout ) :: self real ( rk ), intent ( out ) :: item if ( associated ( self % ptr )) then item = self % ptr % item self % ptr => self % ptr % next end if end subroutine stack_real_iterator_next end module seakeeping_collection_stack_real","tags":"","loc":"sourcefile/seakeeping_collection_stack_real.f90.html"},{"title":"seakeeping_module.f90 – Seakeeping","text":"Contents Modules seakeeping_module Source Code seakeeping_module.f90 Source Code !> Seakeeping 耐波性模块 module seakeeping_module use seakeeping_geometry use seakeeping_collection use seakeeping_constants use seakeeping_kinds use seakeeping_leapfrog use seakeeping_math use seakeeping_statics use seakeeping_tsa use seakeeping_wave implicit none end module seakeeping_module","tags":"","loc":"sourcefile/seakeeping_module.f90.html"},{"title":"seakeeping_collection_vector_real.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_vector_real Source Code seakeeping_collection_vector_real.f90 Source Code !> Vector 实数向量 module seakeeping_collection_vector_real use seakeeping_kinds , only : rk => sk_real_kind implicit none private public :: vector_real !> Vector_real 实数向量 type vector_real private integer , public :: len = 0 !! 有效向量长度 real ( rk ), allocatable :: items (:) !! 实数数组 contains procedure :: init procedure :: push , pop procedure :: get , set procedure :: clear procedure , private :: extend end type vector_real contains !> 初始化向量 pure subroutine init ( self ) class ( vector_real ), intent ( inout ) :: self self % len = 0 if (. not . allocated ( self % items )) allocate ( self % items ( 256 )) end subroutine init !> 向量扩容 pure subroutine extend ( self ) class ( vector_real ), intent ( inout ) :: self real ( rk ), allocatable :: tmp (:) intrinsic :: size allocate ( tmp ( size ( self % items ))) self % items = [ self % items , tmp ] end subroutine extend !> 向量压入 pure subroutine push ( self , item ) class ( vector_real ), intent ( inout ) :: self real ( rk ), intent ( in ) :: item intrinsic :: size if ( self % len == size ( self % items )) call self % extend () self % len = self % len + 1 self % items ( self % len ) = item end subroutine push !> 向量弹出 pure subroutine pop ( self , item ) class ( vector_real ), intent ( inout ) :: self real ( rk ), intent ( out ), optional :: item if ( self % len == 0 ) return if ( present ( item )) item = self % items ( self % len ) self % len = self % len - 1 end subroutine pop !> 向量获取 pure subroutine get ( self , index , item ) class ( vector_real ), intent ( in ) :: self integer , intent ( in ) :: index real ( rk ), intent ( out ) :: item if ( index < 1 . or . index > self % len ) return item = self % items ( index ) end subroutine get !> 向量设置 pure subroutine set ( self , index , item ) class ( vector_real ), intent ( inout ) :: self integer , intent ( in ) :: index real ( rk ), intent ( in ) :: item if ( index < 1 . or . index > self % len ) return self % items ( index ) = item end subroutine set !> 向量清空 pure subroutine clear ( self ) class ( vector_real ), intent ( inout ) :: self deallocate ( self % items ) self % len = 0 end subroutine clear end module seakeeping_collection_vector_real","tags":"","loc":"sourcefile/seakeeping_collection_vector_real.f90.html"},{"title":"seakeeping_math.f90 – Seakeeping","text":"Contents Modules seakeeping_math Source Code seakeeping_math.f90 Source Code !> 耐波性数学 module seakeeping_math use seakeeping_kinds contains !> 海伦公式计算三角形面积 pure real ( kind = sk_real_kind ) function heron_formula ( a , b , c ) result ( s ) real ( kind = sk_real_kind ), intent ( in ) :: a , b , c !! 三边长 (m) associate ( p => ( a + b + c ) / 2 ) s = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c )) end associate end function heron_formula !> 欧拉公式 elemental complex ( kind = sk_real_kind ) function euler_formula ( x ) real ( kind = sk_real_kind ), intent ( in ) :: x euler_formula % re = cos ( x ) euler_formula % im = sin ( x ) end function euler_formula !> 计算两向量的夹角 pure real ( kind = sk_real_kind ) function angle ( x , y ) real ( kind = sk_real_kind ), intent ( in ), dimension ( 3 ) :: x , y !! 两向量 angle = acos ( dot_product ( x , y ) / ( norm2 ( x ) * norm2 ( y ))) end function angle !> 一元二次方程求根公式 pure subroutine root_formula ( a , b , c , x1 , x2 ) real ( kind = sk_real_kind ), intent ( in ) :: a , b , c real ( kind = sk_real_kind ), intent ( out ), optional :: x1 , x2 if ( b * b - 4 * a * c < 0 ) return if ( a > 0 ) then if ( present ( x1 )) x1 = ( - b - sqrt ( b * b - 4 * a * c )) / ( 2 * a ) if ( present ( x2 )) x2 = ( - b + sqrt ( b * b - 4 * a * c )) / ( 2 * a ) else if ( present ( x1 )) x1 = ( - b + sqrt ( b * b - 4 * a * c )) / ( 2 * a ) if ( present ( x2 )) x2 = ( - b - sqrt ( b * b - 4 * a * c )) / ( 2 * a ) end if end subroutine root_formula end module seakeeping_math","tags":"","loc":"sourcefile/seakeeping_math.f90.html"},{"title":"seakeeping_collection_queue.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_queue Source Code seakeeping_collection_queue.f90 Source Code !> Queue 泛型队列 (通用但效率稍低) module seakeeping_collection_queue implicit none private public :: queue , queue_iterator !> 节点 type node private type ( node ), pointer :: next => null () class ( * ), allocatable :: item !! content of the node contains procedure :: clear => node_clear end type node !> 队列 type queue private integer , public :: len = 0 !! number of nodes in the queue type ( node ), pointer :: head => null () !! head of the queue type ( node ), pointer :: tail => null () !! tail of the queue contains procedure :: enqueue => queue_enqueue procedure :: dequeue => queue_dequeue procedure :: iterator procedure :: clear => queue_clear end type queue !> 迭代器 type queue_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => queue_iterator_next procedure :: clear => queue_iterator_clear end type queue_iterator contains !> Initialize the node from a new item pure function init_node ( new_item ) result ( new_node ) class ( * ), intent ( in ) :: new_item type ( node ) new_node allocate ( new_node % item , source = new_item ) end function init_node !> Clear the node pure subroutine node_clear ( self ) class ( node ), intent ( inout ) :: self if ( allocated ( self % item )) deallocate ( self % item ) nullify ( self % next ) end subroutine node_clear !> Enqueue an item to the queue pure subroutine queue_enqueue ( self , item ) class ( queue ), intent ( inout ) :: self class ( * ), intent ( in ) :: item if ( associated ( self % tail )) then allocate ( self % tail % next , source = init_node ( item )) self % tail => self % tail % next else allocate ( self % head , source = init_node ( item )) self % tail => self % head end if self % len = self % len + 1 end subroutine queue_enqueue !> Dequeue an item from the queue subroutine queue_dequeue ( self , item ) class ( queue ), intent ( inout ) :: self class ( * ), intent ( out ), allocatable , optional :: item type ( node ), pointer :: curr_node if ( associated ( self % head )) then if ( present ( item )) then call move_alloc ( self % head % item , item ) else deallocate ( self % head % item ) end if curr_node => self % head self % head => self % head % next self % len = self % len - 1 nullify ( curr_node % next ) deallocate ( curr_node ) if ( self % len == 0 ) then nullify ( self % head , self % tail ) end if end if end subroutine queue_dequeue !> Get an queue_iterator for the queue type ( queue_iterator ) function iterator ( self ) result ( iter ) class ( queue ), intent ( in ) :: self iter % ptr => self % head end function iterator !> Clear the queue pure subroutine queue_clear ( self ) class ( queue ), intent ( inout ) :: self type ( node ), pointer :: curr_node do while ( self % len > 0 ) curr_node => self % head if ( associated ( curr_node % next )) self % head => self % head % next call curr_node % clear () deallocate ( curr_node ) self % len = self % len - 1 end do nullify ( self % head , self % tail ) end subroutine queue_clear !> Clear the queue_iterator pure subroutine queue_iterator_clear ( self ) class ( queue_iterator ), intent ( inout ) :: self nullify ( self % ptr ) end subroutine queue_iterator_clear !> Get the next item from the queue_iterator subroutine queue_iterator_next ( self , item ) class ( queue_iterator ), intent ( inout ) :: self class ( * ), allocatable , intent ( out ) :: item if ( associated ( self % ptr )) then allocate ( item , source = self % ptr % item ) self % ptr => self % ptr % next end if end subroutine queue_iterator_next end module seakeeping_collection_queue","tags":"","loc":"sourcefile/seakeeping_collection_queue.f90.html"},{"title":"seakeeping_collection_stack.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_stack Source Code seakeeping_collection_stack.f90 Source Code !> stack 泛型堆栈 (通用但效率稍低) module seakeeping_collection_stack implicit none private public :: stack , stack_iterator !> 节点 type node private type ( node ), pointer :: prev => null () type ( node ), pointer :: next => null () class ( * ), allocatable :: item !! content of the node contains procedure :: clear => node_clear end type node !> 堆栈 type stack private integer , public :: len = 0 !! number of nodes in the stack type ( node ), pointer :: head => null () !! head of the stack type ( node ), pointer :: tail => null () !! tail of the stack contains procedure :: push => stack_push procedure :: pop => stack_pop procedure :: iterator procedure :: clear => stack_clear end type stack !> 迭代器 type stack_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => stack_iterator_next procedure :: clear => stack_iterator_clear end type stack_iterator contains !> Initialize the node from a new item pure function init_node ( new_item ) result ( new_node ) class ( * ), intent ( in ) :: new_item type ( node ) :: new_node allocate ( new_node % item , source = new_item ) end function init_node !> Clear the node pure subroutine node_clear ( self ) class ( node ), intent ( inout ) :: self if ( allocated ( self % item )) deallocate ( self % item ) nullify ( self % prev ) nullify ( self % next ) end subroutine node_clear !> push an item to the stack pure subroutine stack_push ( self , item ) class ( stack ), intent ( inout ) :: self class ( * ), intent ( in ) :: item if ( associated ( self % tail )) then allocate ( self % tail % next , source = init_node ( item )) self % tail % next % prev => self % tail self % tail => self % tail % next else allocate ( self % head , source = init_node ( item )) self % tail => self % head end if self % len = self % len + 1 end subroutine stack_push !> pop an item from the stack subroutine stack_pop ( self , item ) class ( stack ), intent ( inout ) :: self class ( * ), intent ( out ), allocatable , optional :: item type ( node ), pointer :: curr_node if ( associated ( self % tail )) then if ( present ( item )) then call move_alloc ( self % tail % item , item ) else deallocate ( self % tail % item ) end if curr_node => self % tail self % tail => curr_node % prev self % len = self % len - 1 nullify ( curr_node % prev , curr_node % next ) deallocate ( curr_node ) if ( self % len == 0 ) then nullify ( self % head , self % tail ) end if end if end subroutine stack_pop !> Get an stack_iterator for the stack type ( stack_iterator ) function iterator ( self ) result ( iter ) class ( stack ), intent ( in ) :: self iter % ptr => self % head end function iterator !> Clear the stack pure subroutine stack_clear ( self ) class ( stack ), intent ( inout ) :: self type ( node ), pointer :: curr_node do while ( self % len > 0 ) curr_node => self % head if ( associated ( curr_node % next )) then nullify ( curr_node % next % prev ) self % head => self % head % next end if call curr_node % clear () deallocate ( curr_node ) self % len = self % len - 1 end do nullify ( self % head , self % tail ) end subroutine stack_clear !> Clear the stack_iterator pure subroutine stack_iterator_clear ( self ) class ( stack_iterator ), intent ( inout ) :: self nullify ( self % ptr ) end subroutine stack_iterator_clear !> Get the next item from the stack_iterator subroutine stack_iterator_next ( self , item ) class ( stack_iterator ), intent ( inout ) :: self class ( * ), allocatable , intent ( out ) :: item if ( associated ( self % ptr )) then allocate ( item , source = self % ptr % item ) self % ptr => self % ptr % next end if end subroutine stack_iterator_next end module seakeeping_collection_stack","tags":"","loc":"sourcefile/seakeeping_collection_stack.f90.html"},{"title":"seakeeping_collection_queue_real.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_queue_real Source Code seakeeping_collection_queue_real.f90 Source Code !> Queue 实数队列 module seakeeping_collection_queue_real use seakeeping_kinds , only : rk => sk_real_kind implicit none private public :: queue_real , queue_real_iterator !> 节点 type node private type ( node ), pointer :: next => null () real ( rk ) :: item !! content of the node contains procedure :: clear => node_clear end type node !> 队列 type queue_real private integer , public :: len = 0 !! number of nodes in the queue type ( node ), pointer :: head => null () !! head of the queue type ( node ), pointer :: tail => null () !! tail of the queue contains procedure :: enqueue => queue_enqueue procedure :: dequeue => queue_dequeue procedure :: iterator procedure :: clear => queue_clear end type queue_real !> 迭代器 type queue_real_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => queue_iterator_next procedure :: clear => queue_iterator_clear end type queue_real_iterator contains !> Initialize the node from a new item pure function init_node ( new_item ) result ( new_node ) real ( rk ), intent ( in ) :: new_item type ( node ) new_node new_node % item = new_item end function init_node !> Clear the node pure subroutine node_clear ( self ) class ( node ), intent ( inout ) :: self nullify ( self % next ) end subroutine node_clear !> Enqueue an item to the queue pure subroutine queue_enqueue ( self , item ) class ( queue_real ), intent ( inout ) :: self real ( rk ), intent ( in ) :: item if ( associated ( self % tail )) then allocate ( self % tail % next , source = init_node ( item )) self % tail => self % tail % next else allocate ( self % head , source = init_node ( item )) self % tail => self % head end if self % len = self % len + 1 end subroutine queue_enqueue !> Dequeue an item from the queue pure subroutine queue_dequeue ( self , item ) class ( queue_real ), intent ( inout ) :: self real ( rk ), intent ( out ), optional :: item type ( node ), pointer :: curr_node if ( associated ( self % head )) then if ( present ( item )) then item = self % head % item end if curr_node => self % head self % head => self % head % next self % len = self % len - 1 nullify ( curr_node % next ) deallocate ( curr_node ) if ( self % len == 0 ) then nullify ( self % head , self % tail ) end if end if end subroutine queue_dequeue !> Get an queue_real_iterator for the queue type ( queue_real_iterator ) function iterator ( self ) result ( iter ) class ( queue_real ), intent ( in ) :: self iter % ptr => self % head end function iterator !> Clear the queue pure subroutine queue_clear ( self ) class ( queue_real ), intent ( inout ) :: self type ( node ), pointer :: curr_node do while ( self % len > 0 ) curr_node => self % head if ( associated ( curr_node % next )) self % head => self % head % next call curr_node % clear () deallocate ( curr_node ) self % len = self % len - 1 end do nullify ( self % head , self % tail ) end subroutine queue_clear !> Clear the queue_real_iterator pure subroutine queue_iterator_clear ( self ) class ( queue_real_iterator ), intent ( inout ) :: self nullify ( self % ptr ) end subroutine queue_iterator_clear !> Get the next item from the queue_real_iterator pure subroutine queue_iterator_next ( self , item ) class ( queue_real_iterator ), intent ( inout ) :: self real ( rk ), intent ( out ) :: item if ( associated ( self % ptr )) then item = self % ptr % item self % ptr => self % ptr % next end if end subroutine queue_iterator_next end module seakeeping_collection_queue_real","tags":"","loc":"sourcefile/seakeeping_collection_queue_real.f90.html"},{"title":"seakeeping_constants.f90 – Seakeeping","text":"Contents Modules seakeeping_constants Source Code seakeeping_constants.f90 Source Code !> 耐波性常数 module seakeeping_constants use seakeeping_kinds , only : rk => sk_real_kind implicit none public private :: rk real ( kind = rk ), parameter :: pi = acos ( - 1.0_rk ) real ( kind = rk ), parameter :: pi2 = 2.0_rk * pi real ( kind = rk ), parameter :: g = 9.80665_rk real ( kind = rk ), parameter :: rho_water ( 2 ) = [ 100 0.0_rk , 102 5.0_rk ] real ( kind = rk ), parameter :: rho_air = 1.205_rk real ( kind = rk ), parameter :: p_atm = 10132 5.0_rk real ( kind = rk ), parameter :: kn2ms = 185 2.0_rk / 360 0.0_rk real ( kind = rk ), parameter :: ms2kn = 360 0.0_rk / 185 2.0_rk end module seakeeping_constants","tags":"","loc":"sourcefile/seakeeping_constants.f90.html"},{"title":"seakeeping_collection.f90 – Seakeeping","text":"Contents Modules seakeeping_collection Source Code seakeeping_collection.f90 Source Code !> 数据容器, 旨在灵活存储数据 module seakeeping_collection use seakeeping_collection_queue_real use seakeeping_collection_queue_int use seakeeping_collection_queue use seakeeping_collection_stack_real use seakeeping_collection_stack_int use seakeeping_collection_stack use seakeeping_collection_vector_real use seakeeping_collection_vector_int use seakeeping_collection_vector implicit none end module seakeeping_collection","tags":"","loc":"sourcefile/seakeeping_collection.f90.html"},{"title":"seakeeping_collection_stack_int.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_stack_int Source Code seakeeping_collection_stack_int.f90 Source Code !> stack 整型堆栈 module seakeeping_collection_stack_int implicit none private public :: stack_int , stack_int_iterator !> 节点 type node private type ( node ), pointer :: prev => null () type ( node ), pointer :: next => null () integer :: item !! content of the node contains procedure :: clear => node_clear end type node !> 堆栈 type stack_int private integer , public :: len = 0 !! number of nodes in the stack_int type ( node ), pointer :: head => null () !! head of the stack_int type ( node ), pointer :: tail => null () !! tail of the stack_int contains procedure :: push => stack_int_push procedure :: pop => stack_int_pop procedure :: iterator procedure :: clear => stack_int_clear end type stack_int !> 迭代器 type stack_int_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => stack_int_iterator_next procedure :: clear => stack_int_iterator_clear end type stack_int_iterator contains !> Initialize the node from a new item pure function init_node ( new_item ) result ( new_node ) integer , intent ( in ) :: new_item type ( node ) :: new_node new_node % item = new_item end function init_node !> Clear the node pure subroutine node_clear ( self ) class ( node ), intent ( inout ) :: self nullify ( self % prev ) nullify ( self % next ) end subroutine node_clear !> push an item to the stack_int pure subroutine stack_int_push ( self , item ) class ( stack_int ), intent ( inout ) :: self integer , intent ( in ) :: item if ( associated ( self % tail )) then allocate ( self % tail % next , source = init_node ( item )) self % tail % next % prev => self % tail self % tail => self % tail % next else allocate ( self % head , source = init_node ( item )) self % tail => self % head end if self % len = self % len + 1 end subroutine stack_int_push !> pop an item from the stack_int pure subroutine stack_int_pop ( self , item ) class ( stack_int ), intent ( inout ) :: self integer , intent ( out ), optional :: item type ( node ), pointer :: curr_node if ( associated ( self % tail )) then if ( present ( item )) then item = self % tail % item end if curr_node => self % tail self % tail => curr_node % prev self % len = self % len - 1 nullify ( curr_node % prev , curr_node % next ) deallocate ( curr_node ) if ( self % len == 0 ) then nullify ( self % head , self % tail ) end if end if end subroutine stack_int_pop !> Get an stack_int_iterator for the stack_int type ( stack_int_iterator ) function iterator ( self ) result ( iter ) class ( stack_int ), intent ( in ) :: self iter % ptr => self % head end function iterator !> Clear the stack_int pure subroutine stack_int_clear ( self ) class ( stack_int ), intent ( inout ) :: self type ( node ), pointer :: curr_node do while ( self % len > 0 ) curr_node => self % head if ( associated ( curr_node % next )) then nullify ( curr_node % next % prev ) self % head => self % head % next end if call curr_node % clear () deallocate ( curr_node ) self % len = self % len - 1 end do nullify ( self % head , self % tail ) end subroutine stack_int_clear !> Clear the stack_int_iterator pure subroutine stack_int_iterator_clear ( self ) class ( stack_int_iterator ), intent ( inout ) :: self nullify ( self % ptr ) end subroutine stack_int_iterator_clear !> Get the next item from the stack_int_iterator pure subroutine stack_int_iterator_next ( self , item ) class ( stack_int_iterator ), intent ( inout ) :: self integer , intent ( out ) :: item if ( associated ( self % ptr )) then item = self % ptr % item self % ptr => self % ptr % next end if end subroutine stack_int_iterator_next end module seakeeping_collection_stack_int","tags":"","loc":"sourcefile/seakeeping_collection_stack_int.f90.html"},{"title":"seakeeping_tsa.f90 – Seakeeping","text":"Contents Modules seakeeping_tsa Source Code seakeeping_tsa.f90 Source Code !> author: 左志华 !> date: 2022-09-16 !> !> Seakeeping time series analysis <br> !> 耐波性时间序列分析 module seakeeping_tsa use seakeeping_constants , only : Pi use seakeeping_kinds contains !> Automatic multiscale-based peak detection (AMPD) <br> !> 峰值查找算法 !> @note !> - 由于移动窗体宽度的存在，序列两端的峰值不被查找，如果需要被查找需要填充最小值，extend = T !> - 暂无法实时查找 !> - 查询谷值，可将信号翻转后再查找 pure function AMPD ( data , extend ) result ( location ) real ( sk_real_kind ), intent ( in ) :: data (:) !! Input data <br> !! 数据 logical , intent ( in ), optional :: extend !! Extend data width to get two end peaks <br> !! 是否增强数据宽度以获取两端最大峰值 integer , allocatable :: location (:) !! Peak position <br> !! 峰值位置 integer :: L , N , k , i , row_sum , min_index , extend_size integer , allocatable :: arr_row_sum (:) integer , allocatable :: p_data (:) logical :: extend_ real ( sk_real_kind ), allocatable :: data_ (:) if ( present ( extend )) then extend_ = extend else extend_ = . false . end if ! 确定最佳窗体宽度 N = size ( data ) L = N / 2 + 1 allocate ( arr_row_sum ( L )) do k = 1 , L row_sum = 0 do i = k , N - k if ( i - k == 0 . or . i + k == N + 1 ) cycle if ( data ( i ) > data ( i - k ) . and . data ( i ) > data ( i + k )) row_sum = row_sum - 1 end do arr_row_sum ( k ) = row_sum end do min_index = minloc ( arr_row_sum , dim = 1 ) ! 通过最小值确定最佳窗体宽度，显著提升峰值特征，方便查找峰值 ! 查找峰值 if ( extend_ ) then extend_size = min_index + 1 else extend_size = 0 end if N = N + extend_size * 2 allocate ( p_data ( N ), source = 0 ) if ( extend_ ) then allocate ( data_ ( N )) associate ( min => minval ( data , dim = 1 )) data_ (: extend_size ) = min data_ ( extend_size + 1 : N - extend_size ) = data (:) data_ ( N - extend_size + 1 :) = min end associate else allocate ( data_ ( N ), source = data ) end if do k = 1 , min_index + 1 do i = k , N - k if ( i - k == 0 . or . i + k == N + 1 ) cycle if ( data_ ( i ) > data_ ( i - k ) . and . data_ ( i ) > data_ ( i + k )) p_data ( i ) = p_data ( i ) + 1 end do end do allocate ( location ( 0 )) do i = 1 , N if ( p_data ( i ) == min_index ) location = [ location , i ] end do if ( extend_ ) location = location - extend_size end function AMPD end module seakeeping_tsa","tags":"","loc":"sourcefile/seakeeping_tsa.f90.html"},{"title":"seakeeping_collection_vector_int.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_vector_int Source Code seakeeping_collection_vector_int.f90 Source Code !> Vector 整型向量 module seakeeping_collection_vector_int use seakeeping_kinds , only : rk => sk_real_kind implicit none private public :: vector_int !> Vector_int 整型向量 type vector_int private integer , public :: len = 0 !! 有效向量长度 integer , allocatable :: items (:) !! 整型数组 contains procedure :: init procedure :: push , pop procedure :: get , set procedure :: clear procedure , private :: extend end type vector_int contains !> 初始化向量 pure subroutine init ( self ) class ( vector_int ), intent ( inout ) :: self self % len = 0 if (. not . allocated ( self % items )) allocate ( self % items ( 256 )) end subroutine init !> 向量扩容 pure subroutine extend ( self ) class ( vector_int ), intent ( inout ) :: self integer , allocatable :: tmp (:) allocate ( tmp ( size ( self % items ))) self % items = [ self % items , tmp ] end subroutine extend !> 向量压入 pure subroutine push ( self , item ) class ( vector_int ), intent ( inout ) :: self integer , intent ( in ) :: item if ( self % len == size ( self % items )) call self % extend () self % len = self % len + 1 self % items ( self % len ) = item end subroutine push !> 向量弹出 pure subroutine pop ( self , item ) class ( vector_int ), intent ( inout ) :: self integer , intent ( out ), optional :: item if ( self % len == 0 ) return if ( present ( item )) item = self % items ( self % len ) self % len = self % len - 1 end subroutine pop !> 向量获取 pure subroutine get ( self , index , item ) class ( vector_int ), intent ( in ) :: self integer , intent ( in ) :: index integer , intent ( out ) :: item if ( index < 1 . or . index > self % len ) return item = self % items ( index ) end subroutine get !> 向量设置 pure subroutine set ( self , index , item ) class ( vector_int ), intent ( inout ) :: self integer , intent ( in ) :: index integer , intent ( in ) :: item if ( index < 1 . or . index > self % len ) return self % items ( index ) = item end subroutine set !> 向量清空 pure subroutine clear ( self ) class ( vector_int ), intent ( inout ) :: self deallocate ( self % items ) self % len = 0 end subroutine clear end module seakeeping_collection_vector_int","tags":"","loc":"sourcefile/seakeeping_collection_vector_int.f90.html"},{"title":"seakeeping_geometry.f90 – Seakeeping","text":"Contents Modules seakeeping_geometry Source Code seakeeping_geometry.f90 Source Code !> author: 左志华 !> date: 2022-09-16 !> version: alpha !> !> Seakeeping geometry <br> !> 耐波性几何学 module seakeeping_geometry use seakeeping_kinds use seakeeping_math , only : heron_formula interface centroid procedure :: centroid3l , centroid4l end interface centroid private :: centroid3l , centroid4l interface area procedure :: area3l , area4l end interface area private :: area3l , area4l contains !> Centroid of a triangle <br> !> 三角形形心 pure function centroid3l ( a , b , c ) result ( cen ) real ( sk_real_kind ), intent ( in ) :: a ( 3 ), b ( 3 ), c ( 3 ) real ( sk_real_kind ) :: cen ( 3 ) cen (:) = ( a (:) + b (:) + c (:)) / 3 end function centroid3l !> Centroid of a quadrilateral <br> !> 四边形形心 pure function centroid4l ( a , b , c , d ) result ( cen ) real ( sk_real_kind ), intent ( in ) :: a ( 3 ), b ( 3 ), c ( 3 ), d ( 3 ) real ( sk_real_kind ) :: cen ( 3 ) cen = area3l ( a , b , c ) * centroid3l ( a , b , c ) + area3l ( a , c , d ) * centroid3l ( a , c , d ) end function centroid4l !> Area of a triangle <br> !> 三角形面积 pure function area3l ( a , b , c ) result ( area ) real ( sk_real_kind ), intent ( in ) :: a ( 3 ), b ( 3 ), c ( 3 ) real ( sk_real_kind ) :: area associate ( d1 => distance ( a - b ), & d2 => distance ( b - c ), & d3 => distance ( c - a )) area = heron_formula ( d1 , d2 , d3 ) end associate end function area3l !> Area of a quadrilateral <br> !> 四边形面积 pure function area4l ( a , b , c , d ) result ( area ) real ( sk_real_kind ), intent ( in ) :: a ( 3 ), b ( 3 ), c ( 3 ), d ( 3 ) real ( sk_real_kind ) :: area associate ( d1 => distance ( a - b ), & d2 => distance ( b - c ), & d3 => distance ( c - d ), & d4 => distance ( d - a ), & dc => distance ( a - c )) area = heron_formula ( d1 , d2 , dc ) + heron_formula ( dc , d3 , d4 ) end associate end function area4l !> Distance between two points <br> !> 两点间距离,  d = |\\overrightarrow{ab} |  pure function distance ( a ) result ( dis ) real ( sk_real_kind ), intent ( in ) :: a ( 3 ) real ( sk_real_kind ) :: dis dis = sqrt ( a ( 1 ) * a ( 1 ) + a ( 2 ) * a ( 2 ) + a ( 3 ) * a ( 3 )) end function distance !> Unitize a vector <br> !> 单位化向量 pure function unitize ( x ) result ( y ) real ( sk_real_kind ), intent ( in ), dimension ( 3 ) :: x real ( sk_real_kind ), dimension ( 3 ) :: y y = x / distance ( x ) end function unitize end module seakeeping_geometry","tags":"","loc":"sourcefile/seakeeping_geometry.f90.html"},{"title":"seakeeping_leapfrog.f90 – Seakeeping","text":"Contents Modules seakeeping_leapfrog Source Code seakeeping_leapfrog.f90 Source Code !> leapfrog 算法计算量相对较少，精度适中，可用于力学求解 module seakeeping_leapfrog use seakeeping_kinds , only : rk => sk_real_kind implicit none private public :: leapfrog , leapfrog_init , leapfrog_final contains !> 速度比位移、加速度快半步长，本例程仅用作力学求解，求解一段时间内的力学变化，并更新时间 subroutine leapfrog ( func , x , v , a , t , m , dt , n ) external :: func real ( kind = rk ), intent ( inout ), dimension ( * ) :: x , v , a real ( kind = rk ), intent ( inout ) :: t integer , intent ( in ) :: m real ( kind = rk ), intent ( in ) :: dt integer , intent ( in ) :: n real ( kind = rk ) :: t0 , vtmp ( n ) integer :: i do i = 1 , m t0 = t + dt * i x (: n ) = x (: n ) + v (: n ) * dt vtmp = v (: n ) + a (: n ) * dt / 2 call func ( t , x , vtmp , a ) v (: n ) = v (: n ) + a (: n ) * dt end do if ( m > 0 ) t = t0 end subroutine leapfrog !> 初始化leapfrog算法，初始化加速度及推进速度半步长 subroutine leapfrog_init ( func , x0 , v0 , a0 , t0 , dt , n ) external :: func real ( kind = rk ), intent ( in ), dimension ( * ) :: x0 real ( kind = rk ), intent ( inout ), dimension ( * ) :: v0 real ( kind = rk ), intent ( out ), dimension ( * ) :: a0 real ( kind = rk ), intent ( in ) :: t0 , dt integer , intent ( in ) :: n call func ( t0 , x0 , v0 , a0 ) v0 (: n ) = v0 (: n ) + a0 (: n ) * dt / 2 end subroutine leapfrog_init !> 速度后退半步长，使其与位移、加速度同步 subroutine leapfrog_final ( v0 , a0 , dt , n ) real ( kind = rk ), intent ( inout ), dimension ( * ) :: v0 real ( kind = rk ), intent ( in ), dimension ( * ) :: a0 real ( kind = rk ), intent ( in ) :: dt integer , intent ( in ) :: n v0 (: n ) = v0 (: n ) - a0 (: n ) * dt / 2 end subroutine leapfrog_final end module seakeeping_leapfrog","tags":"","loc":"sourcefile/seakeeping_leapfrog.f90.html"},{"title":"seakeeping_kinds.F90 – Seakeeping","text":"Contents Modules seakeeping_kinds Source Code seakeeping_kinds.F90 Source Code !> author: 左志华 !> date: 2022-09-16 !> !> Seakeeping kinds <br> !> 耐波性例程浮点数、复数精度 module seakeeping_kinds #ifdef REAL64 integer , parameter :: sk_real_kind = kind ( 0.0d0 ) #else integer , parameter :: sk_real_kind = kind ( 0.0 ) #endif end module seakeeping_kinds","tags":"","loc":"sourcefile/seakeeping_kinds.f90.html"},{"title":"seakeeping_collection_queue_int.f90 – Seakeeping","text":"Contents Modules seakeeping_collection_queue_int Source Code seakeeping_collection_queue_int.f90 Source Code !> Queue 整型队列 module seakeeping_collection_queue_int implicit none private public :: queue_int , queue_int_iterator !> 节点 type node private type ( node ), pointer :: next => null () integer :: item !! content of the node contains procedure :: clear => node_clear end type node !> 队列 type queue_int private integer , public :: len = 0 !! number of nodes in the queue type ( node ), pointer :: head => null () !! head of the queue type ( node ), pointer :: tail => null () !! tail of the queue contains procedure :: enqueue => queue_enqueue procedure :: dequeue => queue_dequeue procedure :: iterator procedure :: clear => queue_clear end type queue_int !> 迭代器 type queue_int_iterator private type ( node ), pointer :: ptr => null () contains procedure :: next => queue_iterator_next procedure :: clear => queue_iterator_clear end type queue_int_iterator contains !> Initialize the node from a new item pure function init_node ( new_item ) result ( new_node ) integer , intent ( in ) :: new_item type ( node ) new_node new_node % item = new_item end function init_node !> Clear the node pure subroutine node_clear ( self ) class ( node ), intent ( inout ) :: self nullify ( self % next ) end subroutine node_clear !> Enqueue an item to the queue pure subroutine queue_enqueue ( self , item ) class ( queue_int ), intent ( inout ) :: self integer , intent ( in ) :: item if ( associated ( self % tail )) then allocate ( self % tail % next , source = init_node ( item )) self % tail => self % tail % next else allocate ( self % head , source = init_node ( item )) self % tail => self % head end if self % len = self % len + 1 end subroutine queue_enqueue !> Dequeue an item from the queue subroutine queue_dequeue ( self , item ) class ( queue_int ), intent ( inout ) :: self integer , intent ( out ), optional :: item type ( node ), pointer :: curr_node if ( associated ( self % head )) then if ( present ( item )) then item = self % head % item end if curr_node => self % head self % head => self % head % next self % len = self % len - 1 nullify ( curr_node % next ) deallocate ( curr_node ) if ( self % len == 0 ) then nullify ( self % head , self % tail ) end if end if end subroutine queue_dequeue !> Get an queue_int_iterator for the queue type ( queue_int_iterator ) function iterator ( self ) result ( iter ) class ( queue_int ), intent ( in ) :: self iter % ptr => self % head end function iterator !> Clear the queue pure subroutine queue_clear ( self ) class ( queue_int ), intent ( inout ) :: self type ( node ), pointer :: curr_node do while ( self % len > 0 ) curr_node => self % head if ( associated ( curr_node % next )) self % head => self % head % next call curr_node % clear () deallocate ( curr_node ) self % len = self % len - 1 end do nullify ( self % head , self % tail ) end subroutine queue_clear !> Clear the queue_int_iterator pure subroutine queue_iterator_clear ( self ) class ( queue_int_iterator ), intent ( inout ) :: self nullify ( self % ptr ) end subroutine queue_iterator_clear !> Get the next item from the queue_int_iterator subroutine queue_iterator_next ( self , item ) class ( queue_int_iterator ), intent ( inout ) :: self integer , intent ( out ) :: item if ( associated ( self % ptr )) then item = self % ptr % item self % ptr => self % ptr % next end if end subroutine queue_iterator_next end module seakeeping_collection_queue_int","tags":"","loc":"sourcefile/seakeeping_collection_queue_int.f90.html"},{"title":"User Guide – Seakeeping","text":"用户指南 Warning 本文档正在构建中，尚不完善！","tags":"","loc":"page/index.html"},{"title":"Collection – Seakeeping","text":"数据容器 本仓库提供了以下数据结构： 队列：实数、整型、泛型。 优势：内存开销小、尾部添加O(1)、删除头部O(1)。 应用场景：先进先出、消息队列、容器。 堆栈：实数、整型、泛型。 优势：尾部添加O(1)、删除尾部O(1)。 应用场景：先进后出、函数调用。 自适应数组：实数、整型、泛型。 优势：内存开销小、尾部添加O(1)、查找O(1)、连续存储。 应用场景：保留容量、容器。 由于对内存、CPU敏感的用户可以借鉴本仓库进行自定义数据容器，以获得求解问题的优化方案。","tags":"","loc":"page/collection.html"},{"title":"典型示例代码 – Seakeeping","text":"","tags":"","loc":"page/example/index.html"},{"title":"Leap Frog Integration Method – Seakeeping","text":"蛙跳积分法 蛙跳积分法本身不可用于加速度受速度影响的物理过程，但蛙跳法计算量小，且属于中心差分法，具有适中的精度，\n在力学模拟中十分合适！ leapfrog_init 计算初始时刻的加速度，并使得 速度前进半步长 ，\n并将初始时刻的位移、加速度及前进半步长的速度作为一组数据集合； leapfrog 将数据集合中的位移、速度、加速度均 前进一步长 ，\n得到新的数据集合，并更新位移、加速度所对应的时间。 leapfrog_final 将数据集合中的 速度后退半步长 ，\n使得速度与位移、加速度对应的时间相同。 备注：由于在船舶力学领域，速度verlet积分法的应用场景有限，所以仅支持蛙跳积分法。","tags":"","loc":"page/leapfrog.html"},{"title":"Wave Theory – Seakeeping","text":"波浪理论 zeta 波浪高度计算 语法 z = [[ seakeeping_wave ( module ): zeta ( function )]]( k , x , y , w , t , beta , phase ) 参数 参数 类型 说明 默认值 单位 k real 波数 - - x real x 轴坐标 - m y real y 轴坐标 - m w real 波浪角频率 - rad/s t real 时间 - s beta real 波浪方向 - rad phase real 波浪相位 - rad 返回值 类型 说明 单位 real 波浪高度 m 示例 无 波能谱计算 本仓库支持以下波能谱： 11th-ITTC(1966) 单参数波能谱； 12th-ITTC(1969) 双参数波能谱 (又名, 布氏谱, ISSC 谱): 适合开阔海域； 中国沿海波能谱。 11th-ITTC(1966) 单参数波能谱  S(\\omega ) = \\frac{A}{\\omega &#94;5} \\exp(-\\frac{B}{\\omega &#94;4})   其中,  A = 0.0081*g&#94;2 ,  B = \\frac{3.11}{hs&#94;2} ,  hs  为有义波高,  g = 9.80665 \\mathrm{m/s&#94;2}   为重力加速度。 12th-ITTC(1969) 双参数波能谱  S(\\omega ) = \\frac{A}{\\omega &#94;5} \\exp(-\\frac{B}{\\omega &#94;4})   其中,  A = 173hs&#94;2/T_1&#94;4 ,  B = \\frac{691}{T_1&#94;2} ,  hs  为有义波高,\n T_1 = 2*\\pi m_0/m_1   为波浪的特征周期, 如果缺乏波浪特征周期资料, 可以近似取为观察的平均周期。 中国沿海波能谱  S(\\omega ) = \\frac{0.74}{\\omega &#94;5} \\exp(-(\\frac{g}{U\\omega })&#94;2 )  其中， U = 6.28\\sqrt{hs}  为风速，hs为有义波高,  g = 9.80665 \\mathrm{m/s&#94;2}  为重力加速度。","tags":"","loc":"page/wave.html"}]}